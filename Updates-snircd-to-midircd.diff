From bec654a3c84df820704b0927c2dc253e9dd9c822 Mon Sep 17 00:00:00 2001
From: Andreas Pschorn <source@midiandmore.de>
Date: Fri, 17 Jan 2025 20:30:33 +0100
Subject: [PATCH] Updates snircd to midircd

---
 configure               |    4 +
 configure.in            | 1498 ++++++++++++++++++++-------------------
 include/client.h        |   11 +-
 include/gline.h         |    1 +
 include/handlers.h      |    2 +
 include/ircd_features.h |    2 +
 include/listener.h      |    3 +
 include/msg.h           |    5 +
 include/numeric.h       |    2 +
 include/patchlevel.h    |    2 +-
 include/s_auth.h        |    3 +
 include/s_conf.h        |   15 +
 include/struct.h        |    5 +-
 ircd/Makefile.in        |    1 +
 ircd/channel.c          |   24 +-
 ircd/gline.c            |   45 +-
 ircd/ircd_features.c    |    2 +
 ircd/ircd_lexer.l       |    4 +
 ircd/ircd_parser.y      |   73 +-
 ircd/ircd_string.c      |   12 +-
 ircd/listener.c         |    4 +-
 ircd/m_account.c        |   16 +-
 ircd/m_nick.c           |    2 +
 ircd/m_sethost.c        |   13 +-
 ircd/m_trace.c          |    4 +
 ircd/m_user.c           |    2 +
 ircd/m_webirc.c         |  135 ++++
 ircd/m_whois.c          |    9 +
 ircd/parse.c            |    7 +
 ircd/s_auth.c           |  454 +++++++++---
 ircd/s_bsd.c            |    4 +
 ircd/s_conf.c           |   55 ++
 ircd/s_err.c            |    4 +-
 ircd/s_misc.c           |    3 +
 ircd/s_stats.c          |   26 +
 ircd/s_user.c           |    8 +-
 36 files changed, 1557 insertions(+), 903 deletions(-)
 create mode 100644 ircd/m_webirc.c

diff --git a/configure b/configure
index e074b31..d803b41 100755
--- a/configure
+++ b/configure
@@ -10733,6 +10733,10 @@ if test x"$unet_maxcon" = xunlimited; then
     unet_maxcon=`ulimit -Sn`
 fi
 unet_maxcon=`expr $unet_maxcon - 4`
+NN_MAX_CLIENT_P=262168
+if test "$unet_maxcon" -gt $NN_MAX_CLIENT_P ; then
+    unet_maxcon=$NN_MAX_CLIENT_P
+fi
 echo "$as_me:$LINENO: checking max connections" >&5
 echo $ECHO_N "checking max connections... $ECHO_C" >&6
 
diff --git a/configure.in b/configure.in
index 025a7b6..c998fd6 100644
--- a/configure.in
+++ b/configure.in
@@ -1,747 +1,751 @@
-dnl Prefered emacs editing mode: -*- shell-script -*-
-dnl
-dnl Process this file with autoconf to produce a configure script.
-dnl
-dnl Copyright (c) 1997, by Carlo Wood <carlo@runaway.xs4all.nl>
-dnl Copyright (C) 2001  Kevin L. Mitchell <klmitch@mit.edu>
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 1, or (at your option)
-dnl any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-dnl
-dnl $Id: configure.in,v 1.34.2.1 2005/12/14 03:01:38 entrope Exp $
-
-dnl Make sure we are in the correct directory (someone could have run
-dnl 'configure' with a wrong '--srcdir').
-AC_INIT(ircd/ircd.c)
-
-dnl Set the default prefix
-AC_PREFIX_DEFAULT([$HOME])
-AC_MSG_CHECKING([for installation prefix])
-AC_CACHE_VAL(unet_cv_prefix, [unet_cv_prefix=$HOME])
-if test x"$prefix" != xNONE; then
-    unet_cv_prefix=$prefix
-fi
-AC_MSG_RESULT([$unet_cv_prefix])
-dnl HACK WARNING: We are referencing an autoconf internal variable.  This is
-dnl the only way to force the prefix to be retrieved from the config.cache
-dnl file!
-ac_default_prefix=$unet_cv_prefix
-
-dnl Define the input and output configuration header file.
-AC_CONFIG_HEADER([config.h])
-
-dnl Demand at least version 2.59 of autoconf (for AS_HELP_STRING)
-AC_PREREQ(2.59)
-
-dnl Find out what type of system we are
-AC_CANONICAL_HOST
-
-dnl This should be done early.
-AC_PROG_CC
-
-dnl ANSIfy the C compiler whenever possible.
-AM_PROG_CC_STDC
-
-dnl Checks for libraries.
-
-dnl Locate the library containing crypt
-AC_SEARCH_LIBS(crypt, descrypt crypt, ,
-[AC_MSG_ERROR([Unable to find library containing crypt()])])
-
-dnl Do all the checks necessary to figure out -lnsl / -lsocket stuff
-AC_LIBRARY_NET
-
-dnl Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS(crypt.h poll.h inttypes.h stdint.h sys/devpoll.h sys/epoll.h sys/event.h sys/param.h sys/resource.h sys/socket.h)
-
-dnl Checks for typedefs, structures, and compiler characteristics
-dnl AC_C_CONST
-AC_C_BIGENDIAN
-AC_TYPE_SIZE_T
-AC_HEADER_TIME
-AC_STRUCT_TM
-AC_TYPE_UID_T
-unet_CHECK_TYPE_SIZES
-AC_CHECK_TYPE(struct sockaddr_in6, [unet_have_sockaddr_in6="yes"], [unet_have_sockaddr_in6="no"], [#include <sys/types.h>
-#include <netinet/in.h>])
-
-dnl Check for socklen_t.  In traditional BSD this is an int, but some
-dnl OSes use a different type.  Test until we find something that will
-dnl work properly.  Test borrowed from a patch submitted for Python.
-AC_CHECK_TYPE([socklen_t], ,[
-  AC_MSG_CHECKING([for socklen_t equivalent])
-  AC_CACHE_VAL([curl_cv_socklen_t_equiv],
-  [
-dnl Systems have either "struct sockaddr*" or "void*" as second
-dnl arg to getpeername.
-    curl_cv_socklen_t_equiv=
-    for arg2 in "struct sockaddr" void ; do
-      for t in int size_t unsigned long "unsigned long" ; do
-        AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/socket.h>
-int getpeername (int $arg2 *, $t *);],[$t len;
-  getpeername(0, 0, &len);], [curl_cv_socklen_t_equiv="$t"
-  break])
-      done
-    done
-  ])
-  AC_MSG_RESULT($curl_cv_socklen_t_equiv)
-  AC_DEFINE_UNQUOTED(socklen_t, $curl_cv_socklen_t_equiv,
-      [type to use in place of socklen_t if not defined])],
-  [#include <sys/types.h>
-#include<sys/socket.h>])
-
-dnl Checks for library functions.
-AC_CHECK_FUNCS([kqueue setrlimit getrusage times])
-
-dnl Do we have restarting syscalls ?
-AC_SYS_RESTARTABLE_SYSCALLS
-
-dnl Check for required features for admins?
-AC_MSG_CHECKING([for donuts])
-AC_MSG_RESULT([yes])
-
-dnl Test for programs
-AC_PROG_AWK
-AC_PROG_MAKE_SET
-AC_PROG_INSTALL
-AC_PROG_LN_S
-AC_PATH_PROGS(RMPROG, rm, /bin/rm)
-AC_PATH_PROGS(SHPROG, sh, /bin/sh)
-
-dnl (F)LEX - needed for the new conf file parser
-AC_PROG_LEX
-dnl The autoconf docs say $LEX defaults to 'lex'.  They lie.
-if test "$LEX" = ":" ; then
-  AC_MSG_ERROR([Cannot find flex.])
-elif echo "" | $LEX -V -v --version > /dev/null 2>&1 ; then
-  :
-else
-  AC_MSG_ERROR([Cannot use $LEX as flex.])
-fi
-
-if test -z "$LEXLIB" ; then
-  AC_MSG_FAILURE([Cannot find a library with yywrap() in, but flex was found.
-  It's possible the compiler you're using ($CC) is incompatible with the
-  installed library.])
-fi
-
-LIBS="$LEXLIB $LIBS"
-
-dnl YACC - ditto
-AC_PROG_YACC
-dnl The autoconf docs say $YACC defaults to 'yacc'.  This seems to be true,
-dnl but judging from AC_PROG_LEX, it may not stay true.
-if test "$YACC" = ":" ; then
-  AC_MSG_ERROR([Cannot find yacc.])
-elif echo "" | $YACC -V -v --version > /dev/null 2>&1 ; then
-  :
-else
-dnl byacc does not seem to have any way to test for workingness, so only warn.
-  AC_MSG_WARN([$YACC may not work as yacc.])
-fi
-
-unet_NONBLOCKING
-unet_SIGNALS
-
-dnl Check OS for os_dep files.
-AC_MSG_CHECKING(for OS-dependent information)
-case "$host" in
-    *-linux*)
-	AC_MSG_RESULT([Linux ($host) found.])
-	unet_poll_syscall=yes
-	;;
-
-    *-solaris*)
-	AC_MSG_RESULT([Solaris ($host) found.])
-	if test x"$ac_cv_header_poll_h" = xyes; then
-	    unet_poll_syscall=yes
-	else
-	    unet_poll_syscall=no
-	fi
-        AC_DEFINE([IRCU_SOLARIS], 1, [Define if building on Solaris])
-	;;
-
-    *-sunos*)
-	AC_MSG_RESULT([Solaris ($host) found.])
-	unet_poll_syscall=no
-	;;
-
-    *-openbsd*)
-	AC_MSG_RESULT([OpenBSD ($host) found.])
-	if test x"$ac_cv_header_poll_h" = xyes; then
-	    unet_poll_syscall=yes
-	else
-	    unet_poll_syscall=no
-	fi
-	;;
-
-    *-*bsd*)
-	AC_MSG_RESULT([Generic BSD ($host) found.])
-	if test x"$ac_cv_header_poll_h" = xyes; then
-	    unet_poll_syscall=yes
-	else
-	    unet_poll_syscall=no
-	fi
-	;;
-
-    *-darwin*)
-	AC_MSG_RESULT([Darwin (Mac OS X) ($host) found.])
-	unet_poll_syscall=no
-	;;
-
-    *)
-	AC_MSG_RESULT([Unknown system type $host found.])
-	AC_MSG_WARN([Unknown OS type; using generic routines.])
-	unet_poll_syscall=no
-	;;
-esac
-
-dnl Check user configuration options
-dnl Start with --enable-poll
-AC_MSG_CHECKING([whether to enable use of poll()])
-AC_ARG_ENABLE([poll],
-[  --enable-poll           Force poll to be used regardless of whether or not
-                          it is a system call],
-[unet_cv_enable_poll=$enable_poll],
-[AC_CACHE_VAL(unet_cv_enable_poll,
-[unet_cv_enable_poll=$unet_poll_syscall])])
-
-# Force poll to be disabled if there is no poll.h
-if test x"$ac_cv_header_poll_h" != xyes; then
-    unet_cv_enable_poll=no
-fi
-
-AC_MSG_RESULT([$unet_cv_enable_poll])
-
-if test x"$unet_cv_enable_poll" = xyes; then
-    AC_DEFINE([USE_POLL], 1, [Specify whether or not to use poll()])
-    ENGINE_C=engine_poll.c
-else
-    ENGINE_C=engine_select.c
-fi
-AC_SUBST(ENGINE_C)
-
-dnl Now look for --enable-debug
-AC_MSG_CHECKING([whether to enable debug mode])
-AC_ARG_ENABLE([debug],
-[  --enable-debug          Turn on debugging mode],
-[unet_cv_enable_debug=$enable_debug],
-[AC_CACHE_VAL(unet_cv_enable_debug,
-[unet_cv_enable_debug=no])])
-AC_MSG_RESULT([$unet_cv_enable_debug])
-
-if test x"$unet_cv_enable_debug" = xyes; then
-    AC_DEFINE([DEBUGMODE], 1, [Enable debugging code])
-fi
-
-dnl Now look for --enable-leak-detect
-AC_MSG_CHECKING([whether to enable leak detection])
-AC_ARG_WITH([leak-detect],
-[  --with-leak-detect          Turn on the leak detector(requires patched boehm)],
-[unet_cv_with_leak_detect=$with_leak_detect],
-[AC_CACHE_VAL(unet_cv_with_leak_detect,
-[unet_cv_with_leak_detect=no])])
-AC_MSG_RESULT([$unet_cv_enable_leak_detect])
-
-if test x"$unet_cv_with_leak_detect" != xno; then
-    LIBS="-lgc $LIBS"
-    CFLAGS="-DMDEBUG $CFLAGS"
-    if test x"$unet_cv_with_leak_detect" != xyes; then
-       LIBS="-L$unet_cv_with_leak_detect $LIBS"
-    fi
-fi
-
-AC_ARG_WITH([ipv6],
-    AS_HELP_STRING([--without-ipv6], [disable IPv6 support (default is autodetect)]),
-    [ac_cv_use_ipv6=$withval],
-    [ac_cv_use_ipv6=$unet_have_sockaddr_in6])
-AC_CACHE_CHECK([whether to use IPv6], [ac_cv_use_ipv6], [ac_cv_use_ipv6=no])
-if test x"$ac_cv_use_ipv6" != "xno" ; then
-    AC_DEFINE([IPV6], 1, [Enable IPv6 support])
-fi
-
-dnl And now for --disable-asserts
-AC_MSG_CHECKING([whether to enable asserts])
-AC_ARG_ENABLE([asserts],
-[  --disable-asserts       Disable assertion checking],
-[unet_cv_enable_asserts=$enable_asserts],
-[AC_CACHE_VAL(unet_cv_enable_asserts,
-[unet_cv_enable_asserts=yes])])
-AC_MSG_RESULT([$unet_cv_enable_asserts])
-
-if test x"$unet_cv_enable_asserts" = xno; then
-    AC_DEFINE([NDEBUG], 1, [Disable assertions])
-fi
-
-dnl Now check for --enable-profile
-AC_MSG_CHECKING([whether to enable profiling support (gprof)])
-AC_ARG_ENABLE([profile],
-[  --enable-profile        Enable profiling support (add -pg to CFLAGS and LDFLAGS)],
-[unet_cv_enable_profile=$enable_profile],
-[AC_CACHE_VAL(unet_cv_enable_profile,
-[unet_cv_enable_profile=no])])
-AC_MSG_RESULT([$unet_cv_enable_profile])
-
-if test x"$unet_cv_enable_profile" = xyes; then
-    CFLAGS="-pg $CFLAGS"
-    LDFLAGS="-pg $LDFLAGS"
-fi
-
-dnl Now check for --enable-pedantic
-AC_MSG_CHECKING([whether to enable pedantic compiler warnings])
-AC_ARG_ENABLE([pedantic],
-[  --enable-pedantic       Enable pedantic warnings (add -pedantic to CFLAGS)],
-[unet_cv_enable_pedantic=$enable_pedantic],
-[AC_CACHE_VAL(unet_cv_enable_pedantic,
-[unet_cv_enable_pedantic=no])])
-AC_MSG_RESULT([$unet_cv_enable_pedantic])
-
-if test x"$unet_cv_enable_pedantic" = xyes; then
-    CFLAGS="-pedantic $CFLAGS"
-fi
-
-dnl Now check for --enable-warnings
-AC_MSG_CHECKING([whether to enable compiler warnings])
-AC_ARG_ENABLE([warnings],
-[  --enable-warnings       Enable warnings (add -Wall to CFLAGS)],
-[unet_cv_enable_warnings=$enable_warnings],
-[AC_CACHE_VAL(unet_cv_enable_warnings,
-[unet_cv_enable_warnings=no])])
-AC_MSG_RESULT([$unet_cv_enable_warnings])
-
-if test x"$unet_cv_enable_warnings" = xyes; then
-    CFLAGS="-Wall $CFLAGS"
-fi
-
-dnl --disable-inlines check...
-AC_MSG_CHECKING([whether to enable inlining for a few critical functions])
-AC_ARG_ENABLE([inlines],
-[  --disable-inlines       Disable inlining for a few critical functions],
-[unet_cv_enable_inlines=$enable_inlines],
-[AC_CACHE_VAL(unet_cv_enable_inlines,
-[unet_cv_enable_inlines=yes])])
-AC_MSG_RESULT([$unet_cv_enable_inlines])
-
-if test x"$unet_cv_enable_inlines" = xyes; then
-    AC_DEFINE([FORCEINLINE], 1, [Force inlining for a few critical functions])
-fi
-
-dnl --disable-devpoll check...
-AC_MSG_CHECKING([whether to enable the /dev/poll event engine])
-AC_ARG_ENABLE([devpoll],
-[  --disable-devpoll       Disable the /dev/poll-based engine],
-[unet_cv_enable_devpoll=$enable_devpoll],
-[AC_CACHE_VAL(unet_cv_enable_devpoll,
-[unet_cv_enable_devpoll=yes])])
-
-if test x"$ac_cv_header_sys_devpoll_h" = xno; then
-    unet_cv_enable_devpoll=no
-fi
-
-AC_MSG_RESULT([$unet_cv_enable_devpoll])
-
-if test x"$unet_cv_enable_devpoll" != xno; then
-    AC_DEFINE([USE_DEVPOLL], 1, [Define to enable the /dev/poll engine])
-    ENGINE_C="engine_devpoll.c $ENGINE_C"
-fi
-
-dnl --disable-kqueue check...
-AC_MSG_CHECKING([whether to enable the kqueue event engine])
-AC_ARG_ENABLE([kqueue],
-[  --disable-kqueue        Disable the kqueue-based engine],
-[unet_cv_enable_kqueue=$enable_kqueue],
-[AC_CACHE_VAL(unet_cv_enable_kqueue,
-[unet_cv_enable_kqueue=yes])])
-
-if test x"$ac_cv_header_sys_event_h" = xno -o x"$ac_cv_func_kqueue" = xno; then
-    unet_cv_enable_kqueue=no
-fi
-
-AC_MSG_RESULT([$unet_cv_enable_kqueue])
-
-if test x"$unet_cv_enable_kqueue" != xno; then
-    AC_DEFINE([USE_KQUEUE], 1, [Define to enable the kqueue engine])
-    ENGINE_C="engine_kqueue.c $ENGINE_C"
-fi
-
-dnl --disable-epoll check
-AC_MSG_CHECKING([whether to enable the epoll event engine])
-AC_ARG_ENABLE([epoll],
-[  --disable-epoll         Disable the epoll-based engine],
-[unet_cv_enable_epoll=$enable_epoll],
-[AC_CACHE_VAL(unet_cv_enable_epoll,
-[unet_cv_enable_epoll=yes])])
-
-if test x"$ac_cv_header_sys_epoll_h" = xno -o x"$ac_cv_func_epoll" = xno; then
-    unet_cv_enable_epoll=no
-fi
-
-AC_MSG_RESULT([$unet_cv_enable_epoll])
-
-dnl If we have the header and user has not refused epoll, we still need
-dnl to check whether the functions are properly defined.
-if test x"$unet_cv_enable_epoll" != xno; then
-    AC_MSG_CHECKING([whether epoll functions are properly defined])
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <sys/epoll.h>], [epoll_create(10);])],
-        [AC_MSG_RESULT([yes])],
-        [AC_MSG_RESULT([no])
-         AC_DEFINE([EPOLL_NEED_BODY], 1, [Define to implement epoll system calls])])
-    AC_DEFINE([USE_EPOLL], 1, [Define to enable the epoll engine])
-    ENGINE_C="engine_epoll.c $ENGINE_C"
-fi
-
-dnl How to copy one va_list to another?
-AC_CACHE_CHECK([for va_copy], unet_cv_c_va_copy, [AC_LINK_IFELSE(
-  [AC_LANG_PROGRAM([#include <stdarg.h>], [va_list ap1, ap2; va_copy(ap1, ap2);])],
-  [unet_cv_c_va_copy="yes"],
-  [unet_cv_c_va_copy="no"]
-)])
-if test "$unet_cv_c_va_copy" = "yes" ; then
-  AC_DEFINE(HAVE_VA_COPY, 1, [Define if we have va_copy])
-fi
-
-AC_CACHE_CHECK([for __va_copy], unet_cv_c___va_copy, [AC_LINK_IFELSE(
-  [AC_LANG_PROGRAM([#include <stdarg.h>], [va_list ap1, ap2; __va_copy(ap1, ap2);])],
-  [unet_cv_c___va_copy="yes"],
-  [unet_cv_c___va_copy="no"]
-)])
-if test "$unet_cv_c___va_copy" = "yes" ; then
-  AC_DEFINE(HAVE___VA_COPY, 1, [Define if we have __va_copy])
-fi
-
-dnl --with-symlink lets us set the name of the symlink; defaults to "ircd"
-AC_MSG_CHECKING([what name to give the symlink])
-AC_ARG_WITH([symlink],
-[  --with-symlink=name     Name to give the symlink; if name is "no," no
-                          symlink will be created.],
-[unet_cv_with_symlink=$with_symlink],
-[AC_CACHE_VAL(unet_cv_with_symlink,
-[unet_cv_with_symlink="ircd"])])
-
-if test x"$unet_cv_with_symlink" = xyes; then
-    unet_cv_with_symlink="ircd"
-fi
-
-AC_MSG_RESULT([$unet_cv_with_symlink])
-
-if test x"$unet_cv_with_symlink" = xno; then
-    INSTALL_RULE=install-no-symlink
-    SYMLINK=
-else
-    INSTALL_RULE=install-with-symlink
-    SYMLINK=$unet_cv_with_symlink
-fi
-AC_SUBST(INSTALL_RULE)
-AC_SUBST(SYMLINK)
-
-dnl --with-mode lets us set the permissions on the binary
-AC_MSG_CHECKING([what permissions to set on the installed binary])
-AC_ARG_WITH([mode],
-[  --with-mode=mode        Permissions (in octal) to give the binary],
-[unet_cv_with_mode=$with_mode],
-[AC_CACHE_VAL(unet_cv_with_mode,
-[unet_cv_with_mode=711])])
-
-if test x"$unet_cv_with_mode" = xyes -o x"$unet_cv_with_mode" = xno; then
-    unet_cv_with_mode=711
-fi
-
-AC_MSG_RESULT([$unet_cv_with_mode])
-
-IRCDMODE=$unet_cv_with_mode
-AC_SUBST(IRCDMODE)
-
-dnl --with-owner lets us set the owner of the binary
-changequote(,)dnl
-unet_uid=`id | sed -e 's/.*uid=[0-9]*(//' -e 's/).*//' 2> /dev/null`
-changequote([,])dnl
-AC_MSG_CHECKING([which user should own the installed binary])
-AC_ARG_WITH([owner],
-[  --with-owner=owner      Specify owner of the installed binary],
-[unet_cv_with_owner=$with_owner],
-[AC_CACHE_VAL(unet_cv_with_owner,
-[unet_cv_with_owner=$unet_uid])])
-
-if test x"$unet_cv_with_owner" = xyes -o x"$unet_cv_with_owner" = xno; then
-    unet_cv_with_owner=$unet_uid
-fi
-
-AC_MSG_RESULT([$unet_cv_with_owner])
-
-IRCDOWN=$unet_cv_with_owner
-AC_SUBST(IRCDOWN)
-
-dnl --with-group lets us set the group owner of the binary
-changequote(,)dnl
-unet_gid=`id | sed -e 's/.*gid=[0-9]*(//' -e 's/).*//' 2> /dev/null`
-changequote([,])dnl
-AC_MSG_CHECKING([which group should own the installed binary])
-AC_ARG_WITH([group],
-[  --with-group=group      Specify group owner of the installed binary],
-[unet_cv_with_group=$with_group],
-[AC_CACHE_VAL(unet_cv_with_group,
-[unet_cv_with_group=$unet_gid])])
-
-if test x"$unet_cv_with_group" = xyes -o x"$unet_cv_with_group" = xno; then
-    unet_cv_with_group=$unet_gid
-fi
-
-AC_MSG_RESULT([$unet_cv_with_group])
-
-IRCDGRP=$unet_cv_with_group
-AC_SUBST(IRCDGRP)
-
-dnl --with-domain lets us set the domain name for some statistics-gathering
-unet_domain=
-if test -f /etc/resolv.conf; then
-    unet_domain=`awk '/^domain/ { print $2; exit }' /etc/resolv.conf`
-    if test x"$unet_domain" = x; then
-	unet_domain=`awk '/^search/ { print $2; exit }' /etc/resolv.conf`
-    fi
-fi
-AC_MSG_CHECKING([for site domain name])
-AC_ARG_WITH([domain],
-[  --with-domain=domain    Domain name to use in local statistics gathering],
-[unet_cv_with_domain=$with_domain],
-[AC_CACHE_VAL(unet_cv_with_domain,
-[unet_cv_with_domain=$unet_domain])])
-
-if test x"$unet_cv_with_domain" = xyes -o x"$unet_cv_with_domain" = xno; then
-    unet_cv_with_domain=$unet_domain
-fi
-if test x"$unet_cv_with_domain" = xno; then
-    AC_MSG_ERROR([Unable to determine server DNS domain; use --with-domain to set it])
-fi
-
-AC_MSG_RESULT([$unet_cv_with_domain])
-
-AC_DEFINE_UNQUOTED(DOMAINNAME, "*$unet_cv_with_domain",
-[Domain name to be used for some statistics gathering])
-
-dnl --with-chroot lets us define a directory that we are going to be using
-dnl as the root of our filesystem
-AC_MSG_CHECKING([if chroot operation is desired])
-AC_ARG_WITH([chroot],
-[  --with-chroot=dir       Specify that the server will be operated under
-                          a different root directory given by dir.  See
-                          doc/readme.chroot for more information.],
-[unet_cv_with_chroot=$with_chroot],
-[AC_CACHE_VAL(unet_cv_with_chroot,
-[unet_cv_with_chroot=no])])
-
-if test x"$unet_cv_with_chroot" = xyes; then
-    AC_MSG_ERROR([--with-chroot given with no directory.  See doc/readme.chroot.])
-fi
-
-# Ensure there are no trailing /'s to mess us up
-unet_cv_with_chroot=`echo "$unet_cv_with_chroot" | sed 's%/*$%%'`
-
-AC_MSG_RESULT([$unet_cv_with_chroot])
-
-dnl Determine some default directory names
-dnl
-dnl HACK WARNING: We are referencing an autoconf internal variable.  This is
-dnl the only way to figure out what value $prefix will have when we go to do
-dnl the install--and the only way we can stick that value in our definitions
-dnl of SPATH, etc.
-# Deal with the annoying value "NONE" here
-unet_save_prefix=$prefix
-if test x"$prefix" = xNONE; then
-    prefix=$ac_default_prefix
-else
-    prefix=$prefix
-fi
-
-unet_save_exec_prefix=$exec_prefix
-if test x"$exec_prefix" = xNONE; then
-    exec_prefix=$prefix
-else
-    exec_prefix=$exec_prefix
-fi
-
-# Obtain the actual interesting directories
-unet_bindir=`eval echo "$bindir"`
-unet_libdir=`eval echo "$libdir"`
-
-# Restore the original settings of $prefix and $exec_prefix
-prefix=$unet_save_prefix
-exec_prefix=$unet_save_exec_prefix
-
-dnl Now compute the name of the binary and verify that it will work under
-dnl chroot operation
-AC_MSG_CHECKING([where the binary will be for /restart])
-if test x"$unet_cv_with_symlink" = xno; then
-    unet_spath="$unet_bindir/ircd"
-else
-    unet_spath="$unet_bindir/$unet_cv_with_symlink"
-fi
-AC_MSG_RESULT([$unet_spath])
-
-if test x"$unet_cv_with_chroot" != xno; then
-    if echo "$unet_spath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
-	unet_spath=`echo "$unet_spath" | sed "s%^$unet_cv_with_chroot%%"`
-    else
-	AC_MSG_WARN([Binary $unet_spath not relative to root directory $unet_cv_with_chroot; restarts will probably fail])
-    fi
-fi
-
-AC_DEFINE_UNQUOTED(SPATH, "$unet_spath", [Path to executable for restarts])
-
-dnl --with-dpath sets the all-important DPATH
-AC_MSG_CHECKING([what the data directory should be])
-AC_ARG_WITH([dpath],
-[  --with-dpath=dir        Directory for all server data files],
-[unet_cv_with_dpath=$with_dpath],
-[AC_CACHE_VAL(unet_cv_with_dpath,
-[unet_cv_with_dpath=$unet_libdir])])
-
-if test x"$unet_cv_with_dpath" = xyes -o x"$unet_cv_with_dpath" = xno; then
-    unet_cv_with_dpath=$unet_libdir
-fi
-
-# Ensure there are no trailing /'s to mess us up
-unet_cv_with_dpath=`echo "$unet_cv_with_dpath" | sed 's%/*$%%'`
-
-AC_MSG_RESULT([$unet_cv_with_dpath])
-
-if test x"$unet_cv_with_chroot" != xno; then
-    if echo "$unet_cv_with_dpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
-	unet_dpath=`echo "$unet_cv_with_dpath" | sed "s%^$unet_cv_with_chroot%%"`
-    else
-	AC_MSG_ERROR([Data directory $unet_cv_with_dpath not relative to root directory $unet_cv_with_chroot])
-    fi
-else
-    unet_dpath=$unet_cv_with_dpath
-fi
-
-AC_DEFINE_UNQUOTED(DPATH, "$unet_dpath", [Path to data directory])
-
-DPATH=$unet_cv_with_dpath
-AC_SUBST(DPATH)
-
-dnl --with-cpath allows us to specify the configuration file
-AC_MSG_CHECKING([where the default configuration file resides])
-AC_ARG_WITH([cpath],
-[  --with-cpath=file       Set server configuration file],
-[unet_cv_with_cpath=$with_cpath],
-[AC_CACHE_VAL(unet_cv_with_cpath,
-[unet_cv_with_cpath="ircd.conf"])])
-
-if test x"$unet_cv_with_cpath" = xyes -o x"$unet_cv_with_cpath" = xno; then
-    unet_cv_with_cpath="ircd.conf"
-fi
-
-AC_MSG_RESULT([$unet_cv_with_cpath])
-
-if echo "$unet_cv_with_cpath" | grep '^/' > /dev/null 2>&1; then
-    # Absolute path; check against chroot stuff
-    if test x"$unet_cv_with_chroot" != xno; then
-	if echo "$unet_cv_with_cpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
-	    unet_cpath=`echo "$unet_cv_with_cpath" | sed "s%^$unet_cv_with_chroot%%"`
-	else
-	    AC_MSG_ERROR([Configuration file $unet_cv_with_cpath not relative to root directory $unet_cv_with_chroot])
-	fi
-    else
-	unet_cpath=$unet_cv_with_cpath
-    fi
-else
-    unet_cpath=$unet_cv_with_cpath
-fi
-
-AC_DEFINE_UNQUOTED(CPATH, "$unet_cpath", [Configuration file name])
-
-dnl --with-lpath allows us to specify the default debugging log file
-AC_MSG_CHECKING([where to put the debugging log if debugging enabled])
-AC_ARG_WITH([lpath],
-[  --with-lpath=file       Set the debugging log file],
-[unet_cv_with_lpath=$with_lpath],
-[AC_CACHE_VAL(unet_cv_with_lpath,
-[unet_cv_with_lpath="ircd.log"])])
-
-if test x"$unet_cv_with_lpath" = xyes -o x"$unet_cv_with_lpath" = xno; then
-    unet_cv_with_lpath="ircd.log"
-fi
-
-AC_MSG_RESULT([$unet_cv_with_lpath])
-
-if echo "$unet_cv_with_lpath" | grep '^/' > /dev/null 2>&1; then
-    # Absolute path; check against chroot stuff
-    if test x"$unet_cv_with_chroot" != xno; then
-	if echo "$unet_cv_with_lpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
-	    unet_lpath=`echo "$unet_cv_with_lpath" | sed "s%^$unet_cv_with_chroot%%"`
-	else
-	    AC_MSG_WARN([Log file $unet_cv_with_lpath not relative to root directory $unet_cv_with_chroot; using default ircd.log instead])
-	    unet_cv_with_lpath="ircd.log"
-	    unet_lpath="ircd.log"
-	fi
-    else
-	unet_lpath=$unet_cv_with_lpath
-    fi
-else
-    unet_lpath=$unet_cv_with_lpath
-fi
-
-AC_DEFINE_UNQUOTED(LPATH, "$unet_lpath", [Path to debugging log file])
-
-dnl --with-maxcon allows us to set the maximum connections
-unet_maxcon=`ulimit -Hn`
-if test x"$unet_maxcon" = xunlimited; then
-    unet_maxcon=`ulimit -Sn`
-fi
-unet_maxcon=`expr $unet_maxcon - 4`
-AC_MSG_CHECKING([max connections])
-AC_ARG_WITH([maxcon],
-[  --with-maxcon=maxcon    Maximum number of connections server will accept],
-[unet_cv_with_maxcon=$with_maxcon],
-[AC_CACHE_VAL(unet_cv_with_maxcon,
-[unet_cv_with_maxcon=$unet_maxcon])])
-
-if test x"$unet_cv_with_maxcon" = xyes -o x"$unet_cv_with_maxcon" = xno; then
-    unet_cv_with_maxcon=$unet_maxcon
-fi
-
-AC_MSG_RESULT([$unet_cv_with_maxcon])
-
-AC_DEFINE_UNQUOTED(MAXCONNECTIONS, $unet_cv_with_maxcon,
-[Maximum number of network connections])
-
-dnl Finally really generate all output files:
-AC_OUTPUT(Makefile ircd/Makefile ircd/test/Makefile doc/Makefile, [echo timestamp > stamp-h])
-
-dnl Report configuration
-AC_OUTPUT_COMMANDS([echo "
-ircu is now hopefully configured for your system.
-
-  Host system:         $host_os
-  Prefix:              $prefix
-  Asserts:             $unet_cv_enable_asserts
-  Warnings:            $unet_cv_enable_warnings
-  Debug:               $unet_cv_enable_debug
-  Profile:             $unet_cv_enable_profile
-  Owner/mode:          $unet_cv_with_owner.$unet_cv_with_group ($unet_cv_with_mode)
-  Chroot:              $unet_cv_with_chroot
-
-  Domain:              $unet_cv_with_domain
-  DPath:               $unet_cv_with_dpath
-  CPath:               $unet_cv_with_cpath
-  LPath:               $unet_cv_with_lpath
-  Maximum connections: $unet_cv_with_maxcon
-
-  poll() engine:       $unet_cv_enable_poll
-  kqueue() engine:     $unet_cv_enable_kqueue
-  /dev/poll engine:    $unet_cv_enable_devpoll
-  epoll() engine:      $unet_cv_enable_epoll
-"])
+dnl Prefered emacs editing mode: -*- shell-script -*-
+dnl
+dnl Process this file with autoconf to produce a configure script.
+dnl
+dnl Copyright (c) 1997, by Carlo Wood <carlo@runaway.xs4all.nl>
+dnl Copyright (C) 2001  Kevin L. Mitchell <klmitch@mit.edu>
+dnl
+dnl This program is free software; you can redistribute it and/or modify
+dnl it under the terms of the GNU General Public License as published by
+dnl the Free Software Foundation; either version 1, or (at your option)
+dnl any later version.
+dnl
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+dnl GNU General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU General Public License
+dnl along with this program; if not, write to the Free Software
+dnl Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+dnl
+dnl $Id: configure.in,v 1.34.2.1 2005/12/14 03:01:38 entrope Exp $
+
+dnl Make sure we are in the correct directory (someone could have run
+dnl 'configure' with a wrong '--srcdir').
+AC_INIT(ircd/ircd.c)
+
+dnl Set the default prefix
+AC_PREFIX_DEFAULT([$HOME])
+AC_MSG_CHECKING([for installation prefix])
+AC_CACHE_VAL(unet_cv_prefix, [unet_cv_prefix=$HOME])
+if test x"$prefix" != xNONE; then
+    unet_cv_prefix=$prefix
+fi
+AC_MSG_RESULT([$unet_cv_prefix])
+dnl HACK WARNING: We are referencing an autoconf internal variable.  This is
+dnl the only way to force the prefix to be retrieved from the config.cache
+dnl file!
+ac_default_prefix=$unet_cv_prefix
+
+dnl Define the input and output configuration header file.
+AC_CONFIG_HEADER([config.h])
+
+dnl Demand at least version 2.59 of autoconf (for AS_HELP_STRING)
+AC_PREREQ(2.59)
+
+dnl Find out what type of system we are
+AC_CANONICAL_HOST
+
+dnl This should be done early.
+AC_PROG_CC
+
+dnl ANSIfy the C compiler whenever possible.
+AM_PROG_CC_STDC
+
+dnl Checks for libraries.
+
+dnl Locate the library containing crypt
+AC_SEARCH_LIBS(crypt, descrypt crypt, ,
+[AC_MSG_ERROR([Unable to find library containing crypt()])])
+
+dnl Do all the checks necessary to figure out -lnsl / -lsocket stuff
+AC_LIBRARY_NET
+
+dnl Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS(crypt.h poll.h inttypes.h stdint.h sys/devpoll.h sys/epoll.h sys/event.h sys/param.h sys/resource.h sys/socket.h)
+
+dnl Checks for typedefs, structures, and compiler characteristics
+dnl AC_C_CONST
+AC_C_BIGENDIAN
+AC_TYPE_SIZE_T
+AC_HEADER_TIME
+AC_STRUCT_TM
+AC_TYPE_UID_T
+unet_CHECK_TYPE_SIZES
+AC_CHECK_TYPE(struct sockaddr_in6, [unet_have_sockaddr_in6="yes"], [unet_have_sockaddr_in6="no"], [#include <sys/types.h>
+#include <netinet/in.h>])
+
+dnl Check for socklen_t.  In traditional BSD this is an int, but some
+dnl OSes use a different type.  Test until we find something that will
+dnl work properly.  Test borrowed from a patch submitted for Python.
+AC_CHECK_TYPE([socklen_t], ,[
+  AC_MSG_CHECKING([for socklen_t equivalent])
+  AC_CACHE_VAL([curl_cv_socklen_t_equiv],
+  [
+dnl Systems have either "struct sockaddr*" or "void*" as second
+dnl arg to getpeername.
+    curl_cv_socklen_t_equiv=
+    for arg2 in "struct sockaddr" void ; do
+      for t in int size_t unsigned long "unsigned long" ; do
+        AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/socket.h>
+int getpeername (int $arg2 *, $t *);],[$t len;
+  getpeername(0, 0, &len);], [curl_cv_socklen_t_equiv="$t"
+  break])
+      done
+    done
+  ])
+  AC_MSG_RESULT($curl_cv_socklen_t_equiv)
+  AC_DEFINE_UNQUOTED(socklen_t, $curl_cv_socklen_t_equiv,
+      [type to use in place of socklen_t if not defined])],
+  [#include <sys/types.h>
+#include<sys/socket.h>])
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS([kqueue setrlimit getrusage times])
+
+dnl Do we have restarting syscalls ?
+AC_SYS_RESTARTABLE_SYSCALLS
+
+dnl Check for required features for admins?
+AC_MSG_CHECKING([for donuts])
+AC_MSG_RESULT([yes])
+
+dnl Test for programs
+AC_PROG_AWK
+AC_PROG_MAKE_SET
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PATH_PROGS(RMPROG, rm, /bin/rm)
+AC_PATH_PROGS(SHPROG, sh, /bin/sh)
+
+dnl (F)LEX - needed for the new conf file parser
+AC_PROG_LEX
+dnl The autoconf docs say $LEX defaults to 'lex'.  They lie.
+if test "$LEX" = ":" ; then
+  AC_MSG_ERROR([Cannot find flex.])
+elif echo "" | $LEX -V -v --version > /dev/null 2>&1 ; then
+  :
+else
+  AC_MSG_ERROR([Cannot use $LEX as flex.])
+fi
+
+if test -z "$LEXLIB" ; then
+  AC_MSG_FAILURE([Cannot find a library with yywrap() in, but flex was found.
+  It's possible the compiler you're using ($CC) is incompatible with the
+  installed library.])
+fi
+
+LIBS="$LEXLIB $LIBS"
+
+dnl YACC - ditto
+AC_PROG_YACC
+dnl The autoconf docs say $YACC defaults to 'yacc'.  This seems to be true,
+dnl but judging from AC_PROG_LEX, it may not stay true.
+if test "$YACC" = ":" ; then
+  AC_MSG_ERROR([Cannot find yacc.])
+elif echo "" | $YACC -V -v --version > /dev/null 2>&1 ; then
+  :
+else
+dnl byacc does not seem to have any way to test for workingness, so only warn.
+  AC_MSG_WARN([$YACC may not work as yacc.])
+fi
+
+unet_NONBLOCKING
+unet_SIGNALS
+
+dnl Check OS for os_dep files.
+AC_MSG_CHECKING(for OS-dependent information)
+case "$host" in
+    *-linux*)
+	AC_MSG_RESULT([Linux ($host) found.])
+	unet_poll_syscall=yes
+	;;
+
+    *-solaris*)
+	AC_MSG_RESULT([Solaris ($host) found.])
+	if test x"$ac_cv_header_poll_h" = xyes; then
+	    unet_poll_syscall=yes
+	else
+	    unet_poll_syscall=no
+	fi
+        AC_DEFINE([IRCU_SOLARIS], 1, [Define if building on Solaris])
+	;;
+
+    *-sunos*)
+	AC_MSG_RESULT([Solaris ($host) found.])
+	unet_poll_syscall=no
+	;;
+
+    *-openbsd*)
+	AC_MSG_RESULT([OpenBSD ($host) found.])
+	if test x"$ac_cv_header_poll_h" = xyes; then
+	    unet_poll_syscall=yes
+	else
+	    unet_poll_syscall=no
+	fi
+	;;
+
+    *-*bsd*)
+	AC_MSG_RESULT([Generic BSD ($host) found.])
+	if test x"$ac_cv_header_poll_h" = xyes; then
+	    unet_poll_syscall=yes
+	else
+	    unet_poll_syscall=no
+	fi
+	;;
+
+    *-darwin*)
+	AC_MSG_RESULT([Darwin (Mac OS X) ($host) found.])
+	unet_poll_syscall=no
+	;;
+
+    *)
+	AC_MSG_RESULT([Unknown system type $host found.])
+	AC_MSG_WARN([Unknown OS type; using generic routines.])
+	unet_poll_syscall=no
+	;;
+esac
+
+dnl Check user configuration options
+dnl Start with --enable-poll
+AC_MSG_CHECKING([whether to enable use of poll()])
+AC_ARG_ENABLE([poll],
+[  --enable-poll           Force poll to be used regardless of whether or not
+                          it is a system call],
+[unet_cv_enable_poll=$enable_poll],
+[AC_CACHE_VAL(unet_cv_enable_poll,
+[unet_cv_enable_poll=$unet_poll_syscall])])
+
+# Force poll to be disabled if there is no poll.h
+if test x"$ac_cv_header_poll_h" != xyes; then
+    unet_cv_enable_poll=no
+fi
+
+AC_MSG_RESULT([$unet_cv_enable_poll])
+
+if test x"$unet_cv_enable_poll" = xyes; then
+    AC_DEFINE([USE_POLL], 1, [Specify whether or not to use poll()])
+    ENGINE_C=engine_poll.c
+else
+    ENGINE_C=engine_select.c
+fi
+AC_SUBST(ENGINE_C)
+
+dnl Now look for --enable-debug
+AC_MSG_CHECKING([whether to enable debug mode])
+AC_ARG_ENABLE([debug],
+[  --enable-debug          Turn on debugging mode],
+[unet_cv_enable_debug=$enable_debug],
+[AC_CACHE_VAL(unet_cv_enable_debug,
+[unet_cv_enable_debug=no])])
+AC_MSG_RESULT([$unet_cv_enable_debug])
+
+if test x"$unet_cv_enable_debug" = xyes; then
+    AC_DEFINE([DEBUGMODE], 1, [Enable debugging code])
+fi
+
+dnl Now look for --enable-leak-detect
+AC_MSG_CHECKING([whether to enable leak detection])
+AC_ARG_WITH([leak-detect],
+[  --with-leak-detect          Turn on the leak detector(requires patched boehm)],
+[unet_cv_with_leak_detect=$with_leak_detect],
+[AC_CACHE_VAL(unet_cv_with_leak_detect,
+[unet_cv_with_leak_detect=no])])
+AC_MSG_RESULT([$unet_cv_enable_leak_detect])
+
+if test x"$unet_cv_with_leak_detect" != xno; then
+    LIBS="-lgc $LIBS"
+    CFLAGS="-DMDEBUG $CFLAGS"
+    if test x"$unet_cv_with_leak_detect" != xyes; then
+       LIBS="-L$unet_cv_with_leak_detect $LIBS"
+    fi
+fi
+
+AC_ARG_WITH([ipv6],
+    AS_HELP_STRING([--without-ipv6], [disable IPv6 support (default is autodetect)]),
+    [ac_cv_use_ipv6=$withval],
+    [ac_cv_use_ipv6=$unet_have_sockaddr_in6])
+AC_CACHE_CHECK([whether to use IPv6], [ac_cv_use_ipv6], [ac_cv_use_ipv6=no])
+if test x"$ac_cv_use_ipv6" != "xno" ; then
+    AC_DEFINE([IPV6], 1, [Enable IPv6 support])
+fi
+
+dnl And now for --disable-asserts
+AC_MSG_CHECKING([whether to enable asserts])
+AC_ARG_ENABLE([asserts],
+[  --disable-asserts       Disable assertion checking],
+[unet_cv_enable_asserts=$enable_asserts],
+[AC_CACHE_VAL(unet_cv_enable_asserts,
+[unet_cv_enable_asserts=yes])])
+AC_MSG_RESULT([$unet_cv_enable_asserts])
+
+if test x"$unet_cv_enable_asserts" = xno; then
+    AC_DEFINE([NDEBUG], 1, [Disable assertions])
+fi
+
+dnl Now check for --enable-profile
+AC_MSG_CHECKING([whether to enable profiling support (gprof)])
+AC_ARG_ENABLE([profile],
+[  --enable-profile        Enable profiling support (add -pg to CFLAGS and LDFLAGS)],
+[unet_cv_enable_profile=$enable_profile],
+[AC_CACHE_VAL(unet_cv_enable_profile,
+[unet_cv_enable_profile=no])])
+AC_MSG_RESULT([$unet_cv_enable_profile])
+
+if test x"$unet_cv_enable_profile" = xyes; then
+    CFLAGS="-pg $CFLAGS"
+    LDFLAGS="-pg $LDFLAGS"
+fi
+
+dnl Now check for --enable-pedantic
+AC_MSG_CHECKING([whether to enable pedantic compiler warnings])
+AC_ARG_ENABLE([pedantic],
+[  --enable-pedantic       Enable pedantic warnings (add -pedantic to CFLAGS)],
+[unet_cv_enable_pedantic=$enable_pedantic],
+[AC_CACHE_VAL(unet_cv_enable_pedantic,
+[unet_cv_enable_pedantic=no])])
+AC_MSG_RESULT([$unet_cv_enable_pedantic])
+
+if test x"$unet_cv_enable_pedantic" = xyes; then
+    CFLAGS="-pedantic $CFLAGS"
+fi
+
+dnl Now check for --enable-warnings
+AC_MSG_CHECKING([whether to enable compiler warnings])
+AC_ARG_ENABLE([warnings],
+[  --enable-warnings       Enable warnings (add -Wall to CFLAGS)],
+[unet_cv_enable_warnings=$enable_warnings],
+[AC_CACHE_VAL(unet_cv_enable_warnings,
+[unet_cv_enable_warnings=no])])
+AC_MSG_RESULT([$unet_cv_enable_warnings])
+
+if test x"$unet_cv_enable_warnings" = xyes; then
+    CFLAGS="-Wall $CFLAGS"
+fi
+
+dnl --disable-inlines check...
+AC_MSG_CHECKING([whether to enable inlining for a few critical functions])
+AC_ARG_ENABLE([inlines],
+[  --disable-inlines       Disable inlining for a few critical functions],
+[unet_cv_enable_inlines=$enable_inlines],
+[AC_CACHE_VAL(unet_cv_enable_inlines,
+[unet_cv_enable_inlines=yes])])
+AC_MSG_RESULT([$unet_cv_enable_inlines])
+
+if test x"$unet_cv_enable_inlines" = xyes; then
+    AC_DEFINE([FORCEINLINE], 1, [Force inlining for a few critical functions])
+fi
+
+dnl --disable-devpoll check...
+AC_MSG_CHECKING([whether to enable the /dev/poll event engine])
+AC_ARG_ENABLE([devpoll],
+[  --disable-devpoll       Disable the /dev/poll-based engine],
+[unet_cv_enable_devpoll=$enable_devpoll],
+[AC_CACHE_VAL(unet_cv_enable_devpoll,
+[unet_cv_enable_devpoll=yes])])
+
+if test x"$ac_cv_header_sys_devpoll_h" = xno; then
+    unet_cv_enable_devpoll=no
+fi
+
+AC_MSG_RESULT([$unet_cv_enable_devpoll])
+
+if test x"$unet_cv_enable_devpoll" != xno; then
+    AC_DEFINE([USE_DEVPOLL], 1, [Define to enable the /dev/poll engine])
+    ENGINE_C="engine_devpoll.c $ENGINE_C"
+fi
+
+dnl --disable-kqueue check...
+AC_MSG_CHECKING([whether to enable the kqueue event engine])
+AC_ARG_ENABLE([kqueue],
+[  --disable-kqueue        Disable the kqueue-based engine],
+[unet_cv_enable_kqueue=$enable_kqueue],
+[AC_CACHE_VAL(unet_cv_enable_kqueue,
+[unet_cv_enable_kqueue=yes])])
+
+if test x"$ac_cv_header_sys_event_h" = xno -o x"$ac_cv_func_kqueue" = xno; then
+    unet_cv_enable_kqueue=no
+fi
+
+AC_MSG_RESULT([$unet_cv_enable_kqueue])
+
+if test x"$unet_cv_enable_kqueue" != xno; then
+    AC_DEFINE([USE_KQUEUE], 1, [Define to enable the kqueue engine])
+    ENGINE_C="engine_kqueue.c $ENGINE_C"
+fi
+
+dnl --disable-epoll check
+AC_MSG_CHECKING([whether to enable the epoll event engine])
+AC_ARG_ENABLE([epoll],
+[  --disable-epoll         Disable the epoll-based engine],
+[unet_cv_enable_epoll=$enable_epoll],
+[AC_CACHE_VAL(unet_cv_enable_epoll,
+[unet_cv_enable_epoll=yes])])
+
+if test x"$ac_cv_header_sys_epoll_h" = xno -o x"$ac_cv_func_epoll" = xno; then
+    unet_cv_enable_epoll=no
+fi
+
+AC_MSG_RESULT([$unet_cv_enable_epoll])
+
+dnl If we have the header and user has not refused epoll, we still need
+dnl to check whether the functions are properly defined.
+if test x"$unet_cv_enable_epoll" != xno; then
+    AC_MSG_CHECKING([whether epoll functions are properly defined])
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <sys/epoll.h>], [epoll_create(10);])],
+        [AC_MSG_RESULT([yes])],
+        [AC_MSG_RESULT([no])
+         AC_DEFINE([EPOLL_NEED_BODY], 1, [Define to implement epoll system calls])])
+    AC_DEFINE([USE_EPOLL], 1, [Define to enable the epoll engine])
+    ENGINE_C="engine_epoll.c $ENGINE_C"
+fi
+
+dnl How to copy one va_list to another?
+AC_CACHE_CHECK([for va_copy], unet_cv_c_va_copy, [AC_LINK_IFELSE(
+  [AC_LANG_PROGRAM([#include <stdarg.h>], [va_list ap1, ap2; va_copy(ap1, ap2);])],
+  [unet_cv_c_va_copy="yes"],
+  [unet_cv_c_va_copy="no"]
+)])
+if test "$unet_cv_c_va_copy" = "yes" ; then
+  AC_DEFINE(HAVE_VA_COPY, 1, [Define if we have va_copy])
+fi
+
+AC_CACHE_CHECK([for __va_copy], unet_cv_c___va_copy, [AC_LINK_IFELSE(
+  [AC_LANG_PROGRAM([#include <stdarg.h>], [va_list ap1, ap2; __va_copy(ap1, ap2);])],
+  [unet_cv_c___va_copy="yes"],
+  [unet_cv_c___va_copy="no"]
+)])
+if test "$unet_cv_c___va_copy" = "yes" ; then
+  AC_DEFINE(HAVE___VA_COPY, 1, [Define if we have __va_copy])
+fi
+
+dnl --with-symlink lets us set the name of the symlink; defaults to "ircd"
+AC_MSG_CHECKING([what name to give the symlink])
+AC_ARG_WITH([symlink],
+[  --with-symlink=name     Name to give the symlink; if name is "no," no
+                          symlink will be created.],
+[unet_cv_with_symlink=$with_symlink],
+[AC_CACHE_VAL(unet_cv_with_symlink,
+[unet_cv_with_symlink="ircd"])])
+
+if test x"$unet_cv_with_symlink" = xyes; then
+    unet_cv_with_symlink="ircd"
+fi
+
+AC_MSG_RESULT([$unet_cv_with_symlink])
+
+if test x"$unet_cv_with_symlink" = xno; then
+    INSTALL_RULE=install-no-symlink
+    SYMLINK=
+else
+    INSTALL_RULE=install-with-symlink
+    SYMLINK=$unet_cv_with_symlink
+fi
+AC_SUBST(INSTALL_RULE)
+AC_SUBST(SYMLINK)
+
+dnl --with-mode lets us set the permissions on the binary
+AC_MSG_CHECKING([what permissions to set on the installed binary])
+AC_ARG_WITH([mode],
+[  --with-mode=mode        Permissions (in octal) to give the binary],
+[unet_cv_with_mode=$with_mode],
+[AC_CACHE_VAL(unet_cv_with_mode,
+[unet_cv_with_mode=711])])
+
+if test x"$unet_cv_with_mode" = xyes -o x"$unet_cv_with_mode" = xno; then
+    unet_cv_with_mode=711
+fi
+
+AC_MSG_RESULT([$unet_cv_with_mode])
+
+IRCDMODE=$unet_cv_with_mode
+AC_SUBST(IRCDMODE)
+
+dnl --with-owner lets us set the owner of the binary
+changequote(,)dnl
+unet_uid=`id | sed -e 's/.*uid=[0-9]*(//' -e 's/).*//' 2> /dev/null`
+changequote([,])dnl
+AC_MSG_CHECKING([which user should own the installed binary])
+AC_ARG_WITH([owner],
+[  --with-owner=owner      Specify owner of the installed binary],
+[unet_cv_with_owner=$with_owner],
+[AC_CACHE_VAL(unet_cv_with_owner,
+[unet_cv_with_owner=$unet_uid])])
+
+if test x"$unet_cv_with_owner" = xyes -o x"$unet_cv_with_owner" = xno; then
+    unet_cv_with_owner=$unet_uid
+fi
+
+AC_MSG_RESULT([$unet_cv_with_owner])
+
+IRCDOWN=$unet_cv_with_owner
+AC_SUBST(IRCDOWN)
+
+dnl --with-group lets us set the group owner of the binary
+changequote(,)dnl
+unet_gid=`id | sed -e 's/.*gid=[0-9]*(//' -e 's/).*//' 2> /dev/null`
+changequote([,])dnl
+AC_MSG_CHECKING([which group should own the installed binary])
+AC_ARG_WITH([group],
+[  --with-group=group      Specify group owner of the installed binary],
+[unet_cv_with_group=$with_group],
+[AC_CACHE_VAL(unet_cv_with_group,
+[unet_cv_with_group=$unet_gid])])
+
+if test x"$unet_cv_with_group" = xyes -o x"$unet_cv_with_group" = xno; then
+    unet_cv_with_group=$unet_gid
+fi
+
+AC_MSG_RESULT([$unet_cv_with_group])
+
+IRCDGRP=$unet_cv_with_group
+AC_SUBST(IRCDGRP)
+
+dnl --with-domain lets us set the domain name for some statistics-gathering
+unet_domain=
+if test -f /etc/resolv.conf; then
+    unet_domain=`awk '/^domain/ { print $2; exit }' /etc/resolv.conf`
+    if test x"$unet_domain" = x; then
+	unet_domain=`awk '/^search/ { print $2; exit }' /etc/resolv.conf`
+    fi
+fi
+AC_MSG_CHECKING([for site domain name])
+AC_ARG_WITH([domain],
+[  --with-domain=domain    Domain name to use in local statistics gathering],
+[unet_cv_with_domain=$with_domain],
+[AC_CACHE_VAL(unet_cv_with_domain,
+[unet_cv_with_domain=$unet_domain])])
+
+if test x"$unet_cv_with_domain" = xyes -o x"$unet_cv_with_domain" = xno; then
+    unet_cv_with_domain=$unet_domain
+fi
+if test x"$unet_cv_with_domain" = xno; then
+    AC_MSG_ERROR([Unable to determine server DNS domain; use --with-domain to set it])
+fi
+
+AC_MSG_RESULT([$unet_cv_with_domain])
+
+AC_DEFINE_UNQUOTED(DOMAINNAME, "*$unet_cv_with_domain",
+[Domain name to be used for some statistics gathering])
+
+dnl --with-chroot lets us define a directory that we are going to be using
+dnl as the root of our filesystem
+AC_MSG_CHECKING([if chroot operation is desired])
+AC_ARG_WITH([chroot],
+[  --with-chroot=dir       Specify that the server will be operated under
+                          a different root directory given by dir.  See
+                          doc/readme.chroot for more information.],
+[unet_cv_with_chroot=$with_chroot],
+[AC_CACHE_VAL(unet_cv_with_chroot,
+[unet_cv_with_chroot=no])])
+
+if test x"$unet_cv_with_chroot" = xyes; then
+    AC_MSG_ERROR([--with-chroot given with no directory.  See doc/readme.chroot.])
+fi
+
+# Ensure there are no trailing /'s to mess us up
+unet_cv_with_chroot=`echo "$unet_cv_with_chroot" | sed 's%/*$%%'`
+
+AC_MSG_RESULT([$unet_cv_with_chroot])
+
+dnl Determine some default directory names
+dnl
+dnl HACK WARNING: We are referencing an autoconf internal variable.  This is
+dnl the only way to figure out what value $prefix will have when we go to do
+dnl the install--and the only way we can stick that value in our definitions
+dnl of SPATH, etc.
+# Deal with the annoying value "NONE" here
+unet_save_prefix=$prefix
+if test x"$prefix" = xNONE; then
+    prefix=$ac_default_prefix
+else
+    prefix=$prefix
+fi
+
+unet_save_exec_prefix=$exec_prefix
+if test x"$exec_prefix" = xNONE; then
+    exec_prefix=$prefix
+else
+    exec_prefix=$exec_prefix
+fi
+
+# Obtain the actual interesting directories
+unet_bindir=`eval echo "$bindir"`
+unet_libdir=`eval echo "$libdir"`
+
+# Restore the original settings of $prefix and $exec_prefix
+prefix=$unet_save_prefix
+exec_prefix=$unet_save_exec_prefix
+
+dnl Now compute the name of the binary and verify that it will work under
+dnl chroot operation
+AC_MSG_CHECKING([where the binary will be for /restart])
+if test x"$unet_cv_with_symlink" = xno; then
+    unet_spath="$unet_bindir/ircd"
+else
+    unet_spath="$unet_bindir/$unet_cv_with_symlink"
+fi
+AC_MSG_RESULT([$unet_spath])
+
+if test x"$unet_cv_with_chroot" != xno; then
+    if echo "$unet_spath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
+	unet_spath=`echo "$unet_spath" | sed "s%^$unet_cv_with_chroot%%"`
+    else
+	AC_MSG_WARN([Binary $unet_spath not relative to root directory $unet_cv_with_chroot; restarts will probably fail])
+    fi
+fi
+
+AC_DEFINE_UNQUOTED(SPATH, "$unet_spath", [Path to executable for restarts])
+
+dnl --with-dpath sets the all-important DPATH
+AC_MSG_CHECKING([what the data directory should be])
+AC_ARG_WITH([dpath],
+[  --with-dpath=dir        Directory for all server data files],
+[unet_cv_with_dpath=$with_dpath],
+[AC_CACHE_VAL(unet_cv_with_dpath,
+[unet_cv_with_dpath=$unet_libdir])])
+
+if test x"$unet_cv_with_dpath" = xyes -o x"$unet_cv_with_dpath" = xno; then
+    unet_cv_with_dpath=$unet_libdir
+fi
+
+# Ensure there are no trailing /'s to mess us up
+unet_cv_with_dpath=`echo "$unet_cv_with_dpath" | sed 's%/*$%%'`
+
+AC_MSG_RESULT([$unet_cv_with_dpath])
+
+if test x"$unet_cv_with_chroot" != xno; then
+    if echo "$unet_cv_with_dpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
+	unet_dpath=`echo "$unet_cv_with_dpath" | sed "s%^$unet_cv_with_chroot%%"`
+    else
+	AC_MSG_ERROR([Data directory $unet_cv_with_dpath not relative to root directory $unet_cv_with_chroot])
+    fi
+else
+    unet_dpath=$unet_cv_with_dpath
+fi
+
+AC_DEFINE_UNQUOTED(DPATH, "$unet_dpath", [Path to data directory])
+
+DPATH=$unet_cv_with_dpath
+AC_SUBST(DPATH)
+
+dnl --with-cpath allows us to specify the configuration file
+AC_MSG_CHECKING([where the default configuration file resides])
+AC_ARG_WITH([cpath],
+[  --with-cpath=file       Set server configuration file],
+[unet_cv_with_cpath=$with_cpath],
+[AC_CACHE_VAL(unet_cv_with_cpath,
+[unet_cv_with_cpath="ircd.conf"])])
+
+if test x"$unet_cv_with_cpath" = xyes -o x"$unet_cv_with_cpath" = xno; then
+    unet_cv_with_cpath="ircd.conf"
+fi
+
+AC_MSG_RESULT([$unet_cv_with_cpath])
+
+if echo "$unet_cv_with_cpath" | grep '^/' > /dev/null 2>&1; then
+    # Absolute path; check against chroot stuff
+    if test x"$unet_cv_with_chroot" != xno; then
+	if echo "$unet_cv_with_cpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
+	    unet_cpath=`echo "$unet_cv_with_cpath" | sed "s%^$unet_cv_with_chroot%%"`
+	else
+	    AC_MSG_ERROR([Configuration file $unet_cv_with_cpath not relative to root directory $unet_cv_with_chroot])
+	fi
+    else
+	unet_cpath=$unet_cv_with_cpath
+    fi
+else
+    unet_cpath=$unet_cv_with_cpath
+fi
+
+AC_DEFINE_UNQUOTED(CPATH, "$unet_cpath", [Configuration file name])
+
+dnl --with-lpath allows us to specify the default debugging log file
+AC_MSG_CHECKING([where to put the debugging log if debugging enabled])
+AC_ARG_WITH([lpath],
+[  --with-lpath=file       Set the debugging log file],
+[unet_cv_with_lpath=$with_lpath],
+[AC_CACHE_VAL(unet_cv_with_lpath,
+[unet_cv_with_lpath="ircd.log"])])
+
+if test x"$unet_cv_with_lpath" = xyes -o x"$unet_cv_with_lpath" = xno; then
+    unet_cv_with_lpath="ircd.log"
+fi
+
+AC_MSG_RESULT([$unet_cv_with_lpath])
+
+if echo "$unet_cv_with_lpath" | grep '^/' > /dev/null 2>&1; then
+    # Absolute path; check against chroot stuff
+    if test x"$unet_cv_with_chroot" != xno; then
+	if echo "$unet_cv_with_lpath" | grep "^$unet_cv_with_chroot" > /dev/null 2>&1; then
+	    unet_lpath=`echo "$unet_cv_with_lpath" | sed "s%^$unet_cv_with_chroot%%"`
+	else
+	    AC_MSG_WARN([Log file $unet_cv_with_lpath not relative to root directory $unet_cv_with_chroot; using default ircd.log instead])
+	    unet_cv_with_lpath="ircd.log"
+	    unet_lpath="ircd.log"
+	fi
+    else
+	unet_lpath=$unet_cv_with_lpath
+    fi
+else
+    unet_lpath=$unet_cv_with_lpath
+fi
+
+AC_DEFINE_UNQUOTED(LPATH, "$unet_lpath", [Path to debugging log file])
+
+dnl --with-maxcon allows us to set the maximum connections
+unet_maxcon=`ulimit -Hn`
+if test x"$unet_maxcon" = xunlimited; then
+    unet_maxcon=`ulimit -Sn`
+fi
+unet_maxcon=`expr $unet_maxcon - 4`
+NN_MAX_CLIENT_P=262168
+if test "$unet_maxcon" -gt $NN_MAX_CLIENT_P ; then
+    unet_maxcon=$NN_MAX_CLIENT_P
+fi
+AC_MSG_CHECKING([max connections])
+AC_ARG_WITH([maxcon],
+[  --with-maxcon=maxcon    Maximum number of connections server will accept],
+[unet_cv_with_maxcon=$with_maxcon],
+[AC_CACHE_VAL(unet_cv_with_maxcon,
+[unet_cv_with_maxcon=$unet_maxcon])])
+
+if test x"$unet_cv_with_maxcon" = xyes -o x"$unet_cv_with_maxcon" = xno; then
+    unet_cv_with_maxcon=$unet_maxcon
+fi
+
+AC_MSG_RESULT([$unet_cv_with_maxcon])
+
+AC_DEFINE_UNQUOTED(MAXCONNECTIONS, $unet_cv_with_maxcon,
+[Maximum number of network connections])
+
+dnl Finally really generate all output files:
+AC_OUTPUT(Makefile ircd/Makefile ircd/test/Makefile doc/Makefile, [echo timestamp > stamp-h])
+
+dnl Report configuration
+AC_OUTPUT_COMMANDS([echo "
+ircu is now hopefully configured for your system.
+
+  Host system:         $host_os
+  Prefix:              $prefix
+  Asserts:             $unet_cv_enable_asserts
+  Warnings:            $unet_cv_enable_warnings
+  Debug:               $unet_cv_enable_debug
+  Profile:             $unet_cv_enable_profile
+  Owner/mode:          $unet_cv_with_owner.$unet_cv_with_group ($unet_cv_with_mode)
+  Chroot:              $unet_cv_with_chroot
+
+  Domain:              $unet_cv_with_domain
+  DPath:               $unet_cv_with_dpath
+  CPath:               $unet_cv_with_cpath
+  LPath:               $unet_cv_with_lpath
+  Maximum connections: $unet_cv_with_maxcon
+
+  poll() engine:       $unet_cv_enable_poll
+  kqueue() engine:     $unet_cv_enable_kqueue
+  /dev/poll engine:    $unet_cv_enable_devpoll
+  epoll() engine:      $unet_cv_enable_epoll
+"])
diff --git a/include/client.h b/include/client.h
index 4da341e..06202f3 100644
--- a/include/client.h
+++ b/include/client.h
@@ -249,6 +249,7 @@ struct Connection
   struct CapSet       con_capab;     /**< Client capabilities (from us) */
   struct CapSet       con_active;    /**< Active capabilities (to us) */
   struct AuthRequest* con_auth;      /**< Auth request for client */
+  const struct wline* con_wline;     /**< WebIRC authorization for client */
 };
 
 /** Magic constant to identify valid Connection structures. */
@@ -392,6 +393,8 @@ struct Client {
 #define cli_proc(cli)		con_proc(cli_connect(cli))
 /** Get auth request for client. */
 #define cli_auth(cli)		con_auth(cli_connect(cli))
+/** Get WebIRC authorization for client. */
+#define cli_wline(cli)          con_wline(cli_connect(cli))
 /** Get sentalong marker for client. */
 #define cli_sentalong(cli)      con_sentalong(cli_connect(cli))
 
@@ -473,6 +476,8 @@ struct Client {
 #define con_active(con)         (&(con)->con_active)
 /** Get the auth request for the connection. */
 #define con_auth(con)		((con)->con_auth)
+/** Get the WebIRC block (if any) used by the connection. */
+#define con_wline(con)          ((con)->con_wline)
 
 #define STAT_CONNECTING         0x001 /**< connecting to another server */
 #define STAT_HANDSHAKE          0x002 /**< pass - server sent */
@@ -482,6 +487,7 @@ struct Client {
 #define STAT_UNKNOWN_SERVER     0x020 /**< connection on a server port */
 #define STAT_SERVER             0x040 /**< fully registered server */
 #define STAT_USER               0x080 /**< fully registered user */
+#define STAT_WEBIRC             0x100 /**< connection on a webirc port */
 
 /*
  * status macros.
@@ -498,13 +504,16 @@ struct Client {
 #define IsMe(x)                 (cli_status(x) == STAT_ME)
 /** Return non-zero if the client has not yet registered. */
 #define IsUnknown(x)            (cli_status(x) & \
-        (STAT_UNKNOWN | STAT_UNKNOWN_USER | STAT_UNKNOWN_SERVER))
+        (STAT_UNKNOWN | STAT_UNKNOWN_USER | STAT_UNKNOWN_SERVER | STAT_WEBIRC))
 /** Return non-zero if the client is an unregistered connection on a
  * server port. */
 #define IsServerPort(x)         (cli_status(x) == STAT_UNKNOWN_SERVER )
 /** Return non-zero if the client is an unregistered connection on a
  * user port. */
 #define IsUserPort(x)           (cli_status(x) == STAT_UNKNOWN_USER )
+/** Return non-zero if the client is an unregistered connection on a
+ * WebIRC port that has not yet sent WEBIRC. */
+#define IsWebircPort(x)         (cli_status(x) == STAT_WEBIRC)
 /** Return non-zero if the client is a real client connection. */
 #define IsClient(x)             (cli_status(x) & \
         (STAT_HANDSHAKE | STAT_ME | STAT_UNKNOWN |\
diff --git a/include/gline.h b/include/gline.h
index 502cd42..689a077 100644
--- a/include/gline.h
+++ b/include/gline.h
@@ -116,6 +116,7 @@ extern int gline_resend(struct Client *cptr, struct Gline *gline);
 extern int gline_list(struct Client *sptr, char *userhost);
 extern void gline_stats(struct Client *sptr, const struct StatDesc *sd,
                         char *param);
+extern int do_user_gline(struct Client *cptr, struct Client *sptr, struct Gline *gline);
 extern int gline_memory_count(size_t *gl_size);
 extern struct Gline *IsNickGlined(struct Client *cptr, char *nick);
 
diff --git a/include/handlers.h b/include/handlers.h
index a468201..4f2a98f 100644
--- a/include/handlers.h
+++ b/include/handlers.h
@@ -146,11 +146,13 @@ extern int m_trace(struct Client*, struct Client*, int, char*[]);
 extern int m_unregistered(struct Client*, struct Client*, int, char*[]);
 extern int m_unsupported(struct Client*, struct Client*, int, char*[]);
 extern int m_user(struct Client*, struct Client*, int, char*[]);
+extern int m_webirc(struct Client*, struct Client*, int, char*[]);
 extern int m_userhost(struct Client*, struct Client*, int, char*[]);
 extern int m_userip(struct Client*, struct Client*, int, char*[]);
 extern int m_version(struct Client*, struct Client*, int, char*[]);
 extern int m_wallchops(struct Client*, struct Client*, int, char*[]);
 extern int m_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int m_webirc(struct Client*, struct Client*, int, char*[]);
 extern int m_who(struct Client*, struct Client*, int, char*[]);
 extern int m_whois(struct Client*, struct Client*, int, char*[]);
 extern int m_whowas(struct Client*, struct Client*, int, char*[]);
diff --git a/include/ircd_features.h b/include/ircd_features.h
index 9118f7c..97c9762 100644
--- a/include/ircd_features.h
+++ b/include/ircd_features.h
@@ -142,10 +142,12 @@ enum Feature {
   FEAT_HIS_STATS_U,
   FEAT_HIS_STATS_v,
   FEAT_HIS_STATS_w,
+  FEAT_HIS_STATS_W,
   FEAT_HIS_STATS_x,
   FEAT_HIS_STATS_y,
   FEAT_HIS_STATS_z,
   FEAT_HIS_STATS_IAUTH,
+  FEAT_HIS_WEBIRC,
   FEAT_HIS_WHOIS_SERVERNAME,
   FEAT_HIS_WHOIS_IDLETIME,
   FEAT_HIS_WHOIS_LOCALCHAN,
diff --git a/include/listener.h b/include/listener.h
index 96ce739..0957d8f 100644
--- a/include/listener.h
+++ b/include/listener.h
@@ -52,6 +52,8 @@ enum ListenerFlag {
   LISTEN_IPV4,
   /** Port listens for IPv6 connections. */
   LISTEN_IPV6,
+  /** Port accepts only webirc connections. */
+  LISTEN_WEBIRC,
   /** Sentinel for counting listener flags. */
   LISTEN_LAST_FLAG
 };
@@ -76,6 +78,7 @@ struct Listener {
 
 #define listener_server(LISTENER) FlagHas(&(LISTENER)->flags, LISTEN_SERVER)
 #define listener_active(LISTENER) FlagHas(&(LISTENER)->flags, LISTEN_ACTIVE)
+#define listener_webirc(LISTENER) FlagHas(&(LISTENER)->flags, LISTEN_WEBIRC)
 
 extern void        add_listener(int port, const char* vaddr_ip, 
                                 const char* mask,
diff --git a/include/msg.h b/include/msg.h
index f0ebe3c..c4fe19c 100644
--- a/include/msg.h
+++ b/include/msg.h
@@ -68,6 +68,11 @@ struct Client;
 #define TOK_USER                "USER"
 #define CMD_USER		MSG_USER, TOK_USER
 
+#define MSG_WEBIRC              "WEBIRC"        /* WEBI */
+#define TOK_WEBIRC              "WEBIRC"
+#define CMD_WEBIRC              MSG_WEBIRC, TOK_WEBIRC
+
+
 #define MSG_NICK                "NICK"          /* NICK */
 #define TOK_NICK                "N"
 #define CMD_NICK		MSG_NICK, TOK_NICK
diff --git a/include/numeric.h b/include/numeric.h
index 338920c..6829c4e 100644
--- a/include/numeric.h
+++ b/include/numeric.h
@@ -98,6 +98,7 @@ extern const struct Numeric* get_error_numeric(int err);
 /*      RPL_STATSQLINE       217           Various */
 #define RPL_STATSYLINE       218
 #define RPL_ENDOFSTATS       219        /* See also RPL_STATSDLINE */
+#define RPL_STATSWLINE       220        /* Undernet extension */
 /*      RPL_STATSPLINE       220           Hybrid - Because 217 was for
                                            old Q: lines. */
 /*      RPL_STATSBLINE       220	   Numerics List: Dalnet,unreal */
@@ -233,6 +234,7 @@ extern const struct Numeric* get_error_numeric(int err);
 #define RPL_ENDOFWHOIS       318        /* See RPL_WHOISUSER/RPL_WHOISSERVER/
                                            RPL_WHOISOPERATOR/RPL_WHOISIDLE */
 #define RPL_WHOISCHANNELS    319
+#define RPL_WHOISWEBIRC      320
 /*      RPL_WHOIS_HIDDEN     320         Anothernet +h, ick! */
 /*	RPL_WHOISSPECIAL     320	unreal */
 #define RPL_LISTSTART        321
diff --git a/include/patchlevel.h b/include/patchlevel.h
index c3c42ea..fed89ec 100644
--- a/include/patchlevel.h
+++ b/include/patchlevel.h
@@ -18,7 +18,7 @@
  * $Id: patchlevel.h,v 1.23.2.22 2007/03/09 23:49:31 entrope Exp $
  *
  */
-#define PATCHLEVEL "10+snircd(1.3.4a)"
+#define PATCHLEVEL "10+snircd(1.3.4a)+midircd(1.0.0.a)"
 
 #define RELEASE ".12."
 
diff --git a/include/s_auth.h b/include/s_auth.h
index ce25827..6915571 100644
--- a/include/s_auth.h
+++ b/include/s_auth.h
@@ -32,15 +32,18 @@
 struct Client;
 struct AuthRequest;
 struct StatDesc;
+struct irc_in_addr;
 
 extern void start_auth(struct Client *);
 extern int auth_ping_timeout(struct Client *);
+extern int auth_set_webirc(struct AuthRequest *auth, const char *password, const char *username, const char *hostname, struct irc_in_addr *ip);
 extern int auth_set_pong(struct AuthRequest *auth, unsigned int cookie);
 extern int auth_set_user(struct AuthRequest *auth, const char *username, const char *hostname, const char *servername, const char *userinfo);
 extern int auth_set_nick(struct AuthRequest *auth, const char *nickname);
 extern int auth_set_password(struct AuthRequest *auth, const char *password);
 extern int auth_cap_start(struct AuthRequest *auth);
 extern int auth_cap_done(struct AuthRequest *auth);
+extern int auth_spoof_user(struct AuthRequest *auth, const char *username, const char *hostname, const char *ip);
 extern void destroy_auth_request(struct AuthRequest *req);
 
 extern int auth_spawn(int argc, char *argv[]);
diff --git a/include/s_conf.h b/include/s_conf.h
index 5f119ce..3738556 100644
--- a/include/s_conf.h
+++ b/include/s_conf.h
@@ -80,6 +80,18 @@ struct qline
   char *reason;       /**< Reason for quarantine. */
 };
 
+/** Webirc authorization structure. */
+struct wline
+{
+  struct wline *next;    /**< Next wline in #GlobalWebircList. */
+  struct irc_in_addr ip; /**< IP of webirc service. */
+  unsigned char bits;    /**< Number of bits used in #ip. */
+  unsigned char stale;   /**< Non-zero during config re-read. */
+  unsigned char hidden;  /**< If non-zero, hide IP in /stats webirc. */
+  char *passwd;          /**< Password field. */
+  char *description;     /**< Text description, e.g. for provider. */
+};
+
 struct sline {
   struct sline *next;
   char *spoofhost;
@@ -172,6 +184,8 @@ extern int              GlobalConfCount;
 extern struct s_map*    GlobalServiceMapList;
 extern struct qline*    GlobalQuarantineList;
 extern struct sline*	GlobalSList;
+extern struct wline*    GlobalWebircList;
+extern int              DoIdentLookups;
 
 /*
  * Proto types
@@ -198,6 +212,7 @@ extern int  conf_check_server(struct Client *cptr);
 extern int rehash(struct Client *cptr, int sig);
 extern int find_kill(struct Client *cptr, int glinecheck);
 extern const char *find_quarantine(const char* chname);
+extern const struct wline *find_webirc(const struct irc_in_addr *addr, const char *passwd);
 extern void lookup_confhost(struct ConfItem *aconf);
 extern void conf_parse_userhost(struct ConfItem *aconf, char *host);
 extern struct ConfItem *conf_debug_iline(const char *client);
diff --git a/include/struct.h b/include/struct.h
index 16d9f8e..5f00e26 100644
--- a/include/struct.h
+++ b/include/struct.h
@@ -83,7 +83,10 @@ struct User {
   char               host[HOSTLEN + 1];         /**< displayed hostname */
   char               realusername[USERLEN + 1]; /**< actual username */
   char               realhost[HOSTLEN + 1];     /**< actual hostname */
-  char               account[ACCOUNTLEN + 1];   /**< IRC account name */
+  char               account[ACCOUNTLEN + 1];   /**< actual hostname */
+  char               authhost[ACCOUNTLEN + HOSTLEN + 2];    /**< actual hostname */
+
+  /**< IRC account name */
   time_t	     acc_create;                /**< IRC account timestamp */
   unsigned long       acc_id;                    /**< IRC account unique id */
   char*              opername;                  /**< IRC Oper Account name */
diff --git a/ircd/Makefile.in b/ircd/Makefile.in
index 01a5ea6..430b4be 100644
--- a/ircd/Makefile.in
+++ b/ircd/Makefile.in
@@ -185,6 +185,7 @@ IRCD_SRC = \
 	m_wallops.c \
 	m_wallusers.c \
 	m_wallvoices.c \
+	m_webirc.c \
 	m_who.c \
 	m_whois.c \
 	m_whowas.c \
diff --git a/ircd/channel.c b/ircd/channel.c
index fdb3c25..1c6fcb0 100644
--- a/ircd/channel.c
+++ b/ircd/channel.c
@@ -374,18 +374,27 @@ struct Ban *find_ban(struct Client *cptr, struct Ban *banlist)
   char        tmphost[HOSTLEN + 1];
   char        iphost[SOCKIPLEN + 1];
   char       *hostmask;
-  char       *sr;
+  char       *sr = NULL;
+  char       *rh = NULL;
   struct Ban *found;
 
   /* Build nick!user and alternate host names. */
   ircd_snprintf(0, nu, sizeof(nu), "%s!%s",
                 cli_name(cptr), cli_user(cptr)->username);
   ircd_ntoa_r(iphost, &cli_ip(cptr));
-  if (!IsAccount(cptr))
-    sr = NULL;
-  else if (HasHiddenHost(cptr) || HasSetHost(cptr))
-    sr = cli_user(cptr)->realhost;
-  else
+
+  /* We basically need to check for three things;
+      * Their host (->host) which is always checked
+      * Their real host (->realhost, incase they're +x or +h)
+      * Their hidden host (if they're authed and not +x'd, or +x and +h)
+  */
+  /* If what we're seeing isn't their real host, also check that one */
+  if (HasHiddenHost(cptr) || HasSetHost(cptr))
+    rh = cli_user(cptr)->realhost;
+
+  /* If they're authed but not +x'd, also check the hidden host */
+  /* +h overrides +x */
+  if (IsAccount(cptr) && (!HasHiddenHost(cptr) || (HasHiddenHost(cptr) && HasSetHost(cptr))))
   {
     ircd_snprintf(0, tmphost, HOSTLEN, "%s.%s",
                   cli_user(cptr)->account, feature_str(FEAT_HIDDEN_HOST));
@@ -409,7 +418,8 @@ struct Ban *find_ban(struct Client *cptr, struct Ban *banlist)
     if (!((banlist->flags & BAN_IPMASK)
          && ipmask_check(&cli_ip(cptr), &banlist->address, banlist->addrbits))
         && match(hostmask, cli_user(cptr)->host)
-        && !(sr && !match(hostmask, sr)))
+        && !(sr && !match(hostmask, sr))
+        && !(rh && !match(hostmask, rh)))
         continue;
     /* If an exception matches, no ban can match. */
     if (banlist->flags & BAN_EXCEPTION)
diff --git a/ircd/gline.c b/ircd/gline.c
index b68225d..90f5fd6 100644
--- a/ircd/gline.c
+++ b/ircd/gline.c
@@ -201,6 +201,29 @@ make_gline(char *nick, char *user, char *host, char *reason, time_t expire, time
   return gline;
 }
 
+/** G-line for current user.
+ * If the G-line is inactive, return immediately.
+ * Otherwise, if any users match it, disconnect them.
+ * @param[in] cptr Peer connect that sent the G-line.
+ * @param[in] sptr Client that originated the G-line.
+ * @param[in] gline G-line to check.
+ * @return Zero, unless \a sptr G-lined himself, in which case CPTR_KILLED.
+ */
+int
+do_user_gline(struct Client *cptr, struct Client *sptr, struct Gline *gline)
+{
+    /* ok, here's one that got G-lined */
+    send_reply(sptr, SND_EXPLICIT | ERR_YOUREBANNEDCREEP, ":%s",
+        	   gline->gl_reason);
+
+    /* let the ops know about it */
+    sendto_opmask_butone(0, SNO_GLINE, "G-line active for %s",
+                             get_client_name(sptr, SHOW_IP));
+							 
+    /* Exits victim */
+    return exit_client_msg(cptr, sptr, &me, "G-lined (%s)", gline->gl_reason);
+}
+
 /** Check local clients against a new G-line.
  * If the G-line is inactive, return immediately.
  * Otherwise, if any users match it, disconnect them or kick them if the G-line is a BADCHAN.
@@ -260,28 +283,20 @@ do_gline(struct Client *cptr, struct Client *sptr, struct Gline *gline)
           if (cli_user(acptr)->username &&
               match(gline->gl_user, (cli_user(acptr))->realusername) != 0)
             continue;
-
+	  
           if (GlineIsIpMask(gline)) {
             if (!ipmask_check(&cli_ip(acptr), &gline->gl_addr, gline->gl_bits))
               continue;
           }
           else {
-            if (match(gline->gl_host, cli_sockhost(acptr)) != 0)
+			/* G-Line fix for setted hosts */
+            if (match(gline->gl_host, cli_user(acptr)->host) != 0 && match(gline->gl_host, cli_sockhost(acptr)) != 0 && match(gline->gl_host, cli_user(acptr)->authhost) != 0)
               continue;
           }
         }
-
-        /* ok, here's one that got G-lined */
-        send_reply(acptr, SND_EXPLICIT | ERR_YOUREBANNEDCREEP, ":%s",
-        	   gline->gl_reason);
-
-        /* let the ops know about it */
-        sendto_opmask_butone(0, SNO_GLINE, "G-line active for %s",
-                             get_client_name(acptr, SHOW_IP));
-
-        /* and get rid of him */
-        if ((tval = exit_client_msg(cptr, acptr, &me, "G-lined (%s)", gline->gl_reason))) 
-        retval = tval; /* retain killed status */
+        
+		/* Modified to user gline */
+        retval = do_user_gline(cptr, acptr, gline);
       }
     }
   }
@@ -418,7 +433,7 @@ gline_add(struct Client *cptr, struct Client *sptr, char *userhost,
 {
   struct Gline *agline;
   char uhmask[NICKLEN + USERLEN + HOSTLEN + 3];
-  char *nick, *user, *host;
+  char *nick, *user, *host, *realhost;
   int tmp;
 
   assert(0 != userhost);
diff --git a/ircd/ircd_features.c b/ircd/ircd_features.c
index ffb14a5..3622e1f 100644
--- a/ircd/ircd_features.c
+++ b/ircd/ircd_features.c
@@ -395,10 +395,12 @@ static struct FeatureDesc {
   F_B(HIS_STATS_U, 0, 1, 0),
   F_B(HIS_STATS_v, 0, 1, 0),
   F_B(HIS_STATS_w, 0, 1, 0),
+  F_B(HIS_STATS_W, 0, 1, 0),
   F_B(HIS_STATS_x, 0, 1, 0),
   F_B(HIS_STATS_y, 0, 1, 0),
   F_B(HIS_STATS_z, 0, 1, 0),
   F_B(HIS_STATS_IAUTH, 0, 1, 0),
+  F_B(HIS_WEBIRC, 0, 1, 0),
   F_B(HIS_WHOIS_SERVERNAME, 0, 1, 0),
   F_B(HIS_WHOIS_IDLETIME, 0, 1, 0),
   F_B(HIS_WHOIS_LOCALCHAN, 0, 1, 0),
diff --git a/ircd/ircd_lexer.l b/ircd/ircd_lexer.l
index 4ed667f..ce90003 100644
--- a/ircd/ircd_lexer.l
+++ b/ircd/ircd_lexer.l
@@ -97,6 +97,7 @@ static struct lexer_token {
   TOKEN(TIMEOUT),
   TOKEN(FEATURES),
   TOKEN(CHANNEL),
+  TOKEN(WEBIRC),
   TOKEN(PSEUDO),
   TOKEN(PREPEND),
   TOKEN(USERMODE),
@@ -121,6 +122,8 @@ static struct lexer_token {
   { "gb", GBYTES },
   { "gigabytes", GBYTES },
   { "gline", TPRIV_GLINE },
+  { "hidden", HIDDEN },
+  { "iauth", IAUTH },
   { "ipv4", TOK_IPV4 },
   { "ipv6", TOK_IPV6 },
   { "kb", KBYTES },
@@ -150,6 +153,7 @@ static struct lexer_token {
   { "terabytes", TBYTES },
   { "unlimit_query", TPRIV_UNLIMIT_QUERY },
   { "walk_lchan", TPRIV_WALK_LCHAN },
+  { "webirc", WEBIRC },
   { "wide_gline", TPRIV_WIDE_GLINE },
   { "whox", TPRIV_WHOX },
   { "chanserv", TPRIV_CHANSERV },
diff --git a/ircd/ircd_parser.y b/ircd/ircd_parser.y
index 4dcdb38..da2de56 100644
--- a/ircd/ircd_parser.y
+++ b/ircd/ircd_parser.y
@@ -26,13 +26,14 @@
 #include "class.h"
 #include "client.h"
 #include "crule.h"
-#include "ircd_features.h"
 #include "fileio.h"
 #include "gline.h"
 #include "hash.h"
+#include "IPcheck.h"
 #include "ircd.h"
 #include "ircd_alloc.h"
 #include "ircd_chattr.h"
+#include "ircd_features.h"
 #include "ircd_log.h"
 #include "ircd_reply.h"
 #include "ircd_snprintf.h"
@@ -70,6 +71,7 @@
   extern struct s_map*      GlobalServiceMapList;
   extern struct qline*      GlobalQuarantineList;
   extern struct sline*      GlobalSList;
+  extern struct wline*      GlobalWebircList;
 
   int yylex(void);
   /* Now all the globals we need :/... */
@@ -178,6 +180,7 @@ static void free_slist(struct SLink **link) {
 %token SPOOFHOST
 %token TOK_IPV4 TOK_IPV6
 %token DNS
+%token WEBIRC
 /* and now a lot of privileges... */
 %token TPRIV_CHAN_LIMIT TPRIV_MODE_LCHAN TPRIV_DEOP_LCHAN TPRIV_WALK_LCHAN
 %token TPRIV_LOCAL_KILL TPRIV_REHASH TPRIV_RESTART TPRIV_DIE
@@ -207,7 +210,7 @@ blocks: blocks block | block;
 block: adminblock | generalblock | classblock | connectblock |
        uworldblock | operblock | portblock | jupeblock | clientblock |
        killblock | cruleblock | motdblock | featuresblock | quarantineblock |
-       pseudoblock | iauthblock | spoofblock | error ';';
+       pseudoblock | iauthblock | webircblock | spoofblock | error ';';
 
 /* The timespec, sizespec and expr was ripped straight from
  * ircd-hybrid-7. */
@@ -745,11 +748,14 @@ portblock: PORT '{' portitems '}' ';' {
   port = 0;
 };
 portitems: portitem portitems | portitem;
-portitem: portnumber | portvhost | portvhostnumber | portmask | portserver | porthidden;
+portitem: portnumber | portvhost | portvhostnumber | portmask | portserver | portwebirc | porthidden;
 portnumber: PORT '=' address_family NUMBER ';'
 {
   if ($4 < 1 || $4 > 65535) {
     parse_error("Port %d is out of range", port);
+  } else if (FlagHas(&listen_flags, LISTEN_WEBIRC)
+             && FlagHas(&listen_flags, LISTEN_SERVER)) {
+    parse_error("Port %d cannot be both WEBIRC and SERVER", port);
   } else {
     port = $3 | $4;
     if (hosts && (0 == (hosts->flags & 65535)))
@@ -803,6 +809,14 @@ porthidden: HIDDEN '=' YES ';'
   FlagClr(&listen_flags, LISTEN_HIDDEN);
 };
 
+portwebirc: WEBIRC '=' YES ';'
+{
+  FlagSet(&listen_flags, LISTEN_WEBIRC);
+} | WEBIRC '=' NO ';'
+{
+  FlagClr(&listen_flags, LISTEN_WEBIRC);
+};
+
 clientblock: CLIENT
 {
   maxlinks = 65535;
@@ -841,8 +855,11 @@ clientblock: CLIENT
     MyFree(ip);
     MyFree(pass);
   }
+  if (username)
+    DoIdentLookups = 1;
   host = NULL;
   username = NULL;
+  maxlinks = 0;
   c_class = NULL;
   ip = NULL;
   pass = NULL;
@@ -1172,6 +1189,56 @@ iauthprogram: PROGRAM '='
   }
 } stringlist ';';
 
+webircblock: WEBIRC '{' webircitems '}' ';'
+{
+  struct wline *wline;
+  struct irc_in_addr peer;
+  unsigned char bits;
+
+  if (!ip)
+    parse_error("Missing IP address in WebIRC block");
+  else if (!pass)
+    parse_error("Missing password in WebIRC block");
+  else if (!ipmask_parse(ip, &peer, &bits))
+    parse_error("Invalid IP address in WebIRC block");
+  else {
+    /* Search for a wline with the same IP (mask) and password. */
+    for (wline = GlobalWebircList; wline; wline = wline->next) {
+      if ((bits == wline->bits)
+          && ipmask_check(&peer, &wline->ip, bits)
+          && (0 == strcmp(pass, wline->passwd)))
+        break;
+    }
+
+    /* Update it, or create a new structure. */
+    if (wline) {
+      MyFree(wline->description);
+    } else {
+      wline = (struct wline *) MyMalloc(sizeof(*wline));
+      memcpy(&wline->ip, &peer, sizeof(wline->ip));
+      wline->bits = bits;
+      wline->passwd = pass;
+      wline->next = GlobalWebircList;
+      GlobalWebircList = wline;
+    }
+    wline->stale = 0;
+    wline->hidden = (flags & 1) != 0;
+    wline->description = name;
+
+    MyFree(ip);
+    ip = NULL;
+    pass = NULL;
+    name = NULL;
+  }
+};
+
+webircitems: webircitem | webircitems webircitem;
+webircitem: webircip | webircpass | webircdesc | webirchidden;
+webircip: IP '=' QSTRING ';' { MyFree(ip); ip = $3; };
+webircpass: PASS '=' QSTRING ';' { MyFree(pass); pass = $3; };
+webircdesc: DESCRIPTION '=' QSTRING ';' { MyFree(name); name = $3; };
+webirchidden: HIDDEN '=' YES ';' { flags = flags | 1; }
+
 spoofblock: SPOOFHOST QSTRING '{'
 {
   spoof = MyCalloc(1, sizeof(struct sline));
diff --git a/ircd/ircd_string.c b/ircd/ircd_string.c
index a3e3890..72d3fd1 100644
--- a/ircd/ircd_string.c
+++ b/ircd/ircd_string.c
@@ -524,16 +524,16 @@ ircd_aton_ip4(const char *input, unsigned int *output, unsigned char *pbits)
 int
 ipmask_parse(const char *input, struct irc_in_addr *ip, unsigned char *pbits)
 {
-  char *colon;
+  char *colon_char;
   char *dot;
 
   assert(ip);
   assert(input);
   memset(ip, 0, sizeof(*ip));
-  colon = strchr(input, ':');
+  colon_char = strchr(input, ':');
   dot = strchr(input, '.');
 
-  if (colon && (!dot || (dot > colon))) {
+  if (colon_char && (!dot || (dot > colon_char))) {
     unsigned int part = 0, pos = 0, ii = 0, colon = 8;
     const char *part_start = NULL;
 
@@ -576,6 +576,8 @@ ipmask_parse(const char *input, struct irc_in_addr *ip, unsigned char *pbits)
       if (input[pos] == ':') {
         if (colon < 8)
           return 0;
+        if (ii == 8)
+            return 0;
         colon = ii;
         pos++;
       }
@@ -607,6 +609,8 @@ ipmask_parse(const char *input, struct irc_in_addr *ip, unsigned char *pbits)
       while (input[++pos] == '*' || input[pos] == ':') ;
       if (input[pos] != '\0' || colon < 8)
         return 0;
+      if (part && ii < 8)
+          ip->in6_16[ii++] = htons(part);
       if (pbits)
         *pbits = ii * 16;
       return pos;
@@ -620,6 +624,8 @@ ipmask_parse(const char *input, struct irc_in_addr *ip, unsigned char *pbits)
     default:
       return 0;
     }
+    if (input[pos] != '\0')
+      return 0;
   finish:
     if (colon < 8) {
       unsigned int jj;
diff --git a/ircd/listener.c b/ircd/listener.c
index cfa833c..6533e67 100644
--- a/ircd/listener.c
+++ b/ircd/listener.c
@@ -146,7 +146,9 @@ void show_ports(struct Client* sptr, const struct StatDesc* sd,
     if (port && port != listener->addr.port)
       continue;
     len = 0;
-    flags[len++] = listener_server(listener) ? 'S' : 'C';
+    flags[len++] = listener_server(listener) ? 'S'
+        : listener_webirc(listener) ? 'W'
+        : 'C';
     if (FlagHas(&listener->flags, LISTEN_HIDDEN))
     {
       if (!show_hidden)
diff --git a/ircd/m_account.c b/ircd/m_account.c
index 9ceae55..176edf0 100644
--- a/ircd/m_account.c
+++ b/ircd/m_account.c
@@ -81,13 +81,17 @@
 #include "config.h"
 
 #include "client.h"
+#include "gline.h"
 #include "ircd.h"
+#include "ircd_features.h"
 #include "ircd_log.h"
 #include "ircd_reply.h"
 #include "ircd_string.h"
 #include "msg.h"
+#include "numeric.h"
 #include "numnicks.h"
 #include "s_debug.h"
+#include "s_misc.h"
 #include "s_user.h"
 #include "send.h"
 
@@ -108,6 +112,7 @@ int ms_account(struct Client* cptr, struct Client* sptr, int parc,
 	       char* parv[])
 {
   struct Client *acptr;
+  struct Gline *gline;
 
   if (parc < 3)
     return need_more_params(sptr, "ACCOUNT");
@@ -159,8 +164,7 @@ int ms_account(struct Client* cptr, struct Client* sptr, int parc,
   }
 
   ircd_strncpy(cli_user(acptr)->account, parv[2], ACCOUNTLEN);
-  hide_hostmask(acptr, FLAG_ACCOUNT);
-
+    hide_hostmask(acptr, FLAG_ACCOUNT);
    if (cli_user(acptr)->acc_id) {
      sendcmdto_serv_butone(sptr, CMD_ACCOUNT, cptr, "%C %s %Tu %lu",
                            acptr, cli_user(acptr)->account,
@@ -174,6 +178,12 @@ int ms_account(struct Client* cptr, struct Client* sptr, int parc,
      sendcmdto_serv_butone(sptr, CMD_ACCOUNT, cptr, "%C %s",
                            acptr, cli_user(acptr)->account);
    }
-
+  /* G-Line fix for accounts */
+  strcpy(cli_user(acptr)->authhost, parv[2]);
+  strcat(cli_user(acptr)->authhost, ".");
+  strcat(cli_user(acptr)->authhost, feature_str(FEAT_HIDDEN_HOST));	
+  if ((gline = gline_find(cli_user(acptr)->authhost, GLINE_ANY | GLINE_EXACT)) != 0) {
+	  do_user_gline(cptr, acptr, gline);
+  }
   return 0;
 }
diff --git a/ircd/m_nick.c b/ircd/m_nick.c
index 858e84a..f57f1f6 100644
--- a/ircd/m_nick.c
+++ b/ircd/m_nick.c
@@ -154,6 +154,8 @@ int m_nick(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
 
   if (IsServerPort(cptr))
     return exit_client(cptr, cptr, &me, "Use a different port");
+  if (IsWebircPort(cptr) && !cli_wline(cptr))
+    return exit_client(cptr, cptr, &me, "WebIRC authorization required");
 
   /*
    * parv[0] will be empty for clients connecting for the first time
diff --git a/ircd/m_sethost.c b/ircd/m_sethost.c
index f95bc31..d0aa3a5 100644
--- a/ircd/m_sethost.c
+++ b/ircd/m_sethost.c
@@ -82,6 +82,7 @@
 #include "config.h"
 
 #include "client.h"
+#include "gline.h"
 #include "ircd_reply.h"
 #include "ircd_string.h"
 #include "ircd_snprintf.h"
@@ -158,7 +159,8 @@ int m_sethost(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
       }
       if (set_hostmask(sptr, parv[1], parv[2]))
         FlagClr(&setflags, FLAG_SETHOST);
-    }
+	}
+	
   }  
 
   send_umode_out(cptr, sptr, &setflags, 0);
@@ -180,6 +182,7 @@ int ms_sethost(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
   char hostmask[USERLEN + HOSTLEN + 2];
   struct Membership *chan;
   struct Flags setflags;
+  struct Gline *gline;
 
   if (parc < 4)
     return need_more_params(sptr, "SETHOST");
@@ -214,14 +217,13 @@ int ms_sethost(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
   ircd_snprintf(0, hostmask, USERLEN + HOSTLEN + 2, "%s@%s", parv[2], parv[3]);
   if (!is_hostmask(hostmask))
     return protocol_violation(cptr, "Bad Host mask %s for user %s", hostmask, cli_name(target));
-
   sendcmdto_common_channels_butone(target, CMD_QUIT, target, ":Host change");
 
   /* Assign and propagate the fakehost */
   SetSetHost(target);
   ircd_strncpy(cli_user(target)->username, parv[2], USERLEN);
   ircd_strncpy(cli_user(target)->host, parv[3], HOSTLEN);
-  
+
   send_reply(target, RPL_HOSTHIDDEN, hostmask);
 
   /*
@@ -251,5 +253,10 @@ int ms_sethost(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
   }
 
   send_umode_out(target, target, &setflags, 0);
+  
+  /* G-Line fix for setted hosts */
+  if ((gline = gline_find(parv[3], GLINE_ANY | GLINE_EXACT)) != 0) {
+	 return do_user_gline(cptr, target, gline);
+  }
   return 0;
 }
diff --git a/ircd/m_trace.c b/ircd/m_trace.c
index e35f2be..ec9f7b0 100644
--- a/ircd/m_trace.c
+++ b/ircd/m_trace.c
@@ -219,6 +219,10 @@ void do_trace(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
       case STAT_ME:
         break;
       case STAT_UNKNOWN:
+      case STAT_WEBIRC:
+        send_reply(sptr, RPL_TRACEUNKNOWN, conClass,
+                   get_client_name(acptr, HIDE_IP));
+        break;
       case STAT_UNKNOWN_USER:
 	send_reply(sptr, RPL_TRACEUNKNOWN, conClass,
 		   get_client_name(acptr, HIDE_IP));
diff --git a/ircd/m_user.c b/ircd/m_user.c
index 03d6078..1d72194 100644
--- a/ircd/m_user.c
+++ b/ircd/m_user.c
@@ -122,6 +122,8 @@ int m_user(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
 
   if (IsServerPort(cptr))
     return exit_client(cptr, cptr, &me, "Use a different port");
+  if (IsWebircPort(cptr) && !cli_wline(cptr))
+    return exit_client(cptr, cptr, &me, "WebIRC authorization required");
 
   if (parc < 5)
     return need_more_params(sptr, "USER");
diff --git a/ircd/m_webirc.c b/ircd/m_webirc.c
new file mode 100644
index 0000000..34e5255
--- /dev/null
+++ b/ircd/m_webirc.c
@@ -0,0 +1,135 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_create.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id$
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "client.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "s_auth.h"
+#include "s_conf.h"
+#include "s_misc.h"
+
+#include <string.h>
+
+/*
+ * m_webirc
+ *
+ * parv[0] = sender prefix
+ * parv[1] = password
+ * parv[2] = ident
+ * parv[3] = hostname
+ * parv[4] = ip
+ */
+int m_webirc(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
+{
+  const struct wline *wline;
+  const char *passwd;
+  const char *hostname;
+  const char *ip;
+
+  if (!IsWebircPort(cptr))
+    return exit_client(cptr, cptr, &me, "Use a different port");
+
+  if (parc < 5)
+    return need_more_params(sptr, "WEBIRC");
+
+  passwd = parv[1];
+  hostname = parv[3];
+  ip = parv[4];
+
+  if (EmptyString(ip))
+    return exit_client(cptr, cptr, &me, "WEBIRC needs IP address");
+
+  if (!(wline = find_webirc(&cli_ip(sptr), passwd)))
+    return exit_client_msg(cptr, cptr, &me, "WEBIRC not authorized");
+  cli_wline(sptr) = wline;
+
+  /* Treat client as a normally connecting user from now on. */
+  cli_status(sptr) = STAT_UNKNOWN_USER;
+
+  int res = auth_spoof_user(cli_auth(cptr), NULL, hostname, ip);
+  if (res > 0)
+    return exit_client(cptr, cptr, &me, "WEBIRC invalid spoof");
+  return res;
+}
diff --git a/ircd/m_whois.c b/ircd/m_whois.c
index ed84d5b..a1ced82 100644
--- a/ircd/m_whois.c
+++ b/ircd/m_whois.c
@@ -93,6 +93,7 @@
 #include "msg.h"
 #include "numeric.h"
 #include "numnicks.h"
+#include "s_conf.h"
 #include "s_user.h"
 #include "send.h"
 #include "whocmds.h"
@@ -202,6 +203,8 @@ static void do_whois(struct Client* sptr, struct Client *acptr, int parc)
 
   if (user)
   {
+    const struct wline *wline;
+	
     if (user->away)
        send_reply(sptr, RPL_AWAY, name, user->away);
 
@@ -231,6 +234,12 @@ static void do_whois(struct Client* sptr, struct Client *acptr, int parc)
                               sptr == acptr || parc >= 3))))
        send_reply(sptr, RPL_WHOISIDLE, name, CurrentTime - user->last,
                   cli_firsttime(acptr));
+    if (MyConnect(acptr)
+        && ((parc >= 3 && !feature_bool(FEAT_HIS_WEBIRC))
+            || sptr == acptr || IsAnOper(sptr))
+        && ((wline = cli_wline(acptr)) != NULL))
+        send_reply(sptr, RPL_WHOISWEBIRC, name, wline->description
+                   ? wline->description : "(unspecified WebIRC proxy)");
   }
 }
 
diff --git a/ircd/parse.c b/ircd/parse.c
index dd56879..06d1596 100644
--- a/ircd/parse.c
+++ b/ircd/parse.c
@@ -281,6 +281,13 @@ struct Message msgtab[] = {
     /* UNREG, CLIENT, SERVER, OPER, SERVICE */
     { m_user, m_registered, m_ignore, m_registered, m_ignore }
   },
+  {
+    MSG_WEBIRC,
+    TOK_WEBIRC,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE */
+    { m_webirc, m_registered, m_ignore, m_registered, m_ignore }
+  },
   {
     MSG_AWAY,
     TOK_AWAY,
diff --git a/ircd/s_auth.c b/ircd/s_auth.c
index bfd58c0..9309396 100644
--- a/ircd/s_auth.c
+++ b/ircd/s_auth.c
@@ -72,6 +72,7 @@
 
 /** Pending operations during registration. */
 enum AuthRequestFlag {
+    AR_UNUSED,          /**< unused bit, see check_auth_finished() */
     AR_AUTH_PENDING,    /**< ident connecting or waiting for response */
     AR_DNS_PENDING,     /**< dns request sent, waiting for response */
     AR_CAP_PENDING,     /**< in middle of CAP negotiations */
@@ -83,7 +84,8 @@ enum AuthRequestFlag {
     AR_IAUTH_HURRY,     /**< we told iauth to hurry up */
     AR_IAUTH_USERNAME,  /**< iauth sent a username (preferred or forced) */
     AR_IAUTH_FUSERNAME, /**< iauth sent a forced username */
-    AR_PASSWORD_CHECKED, /**< client password already checked */
+    AR_IAUTH_SOFT_DONE, /**< iauth has no objection to client */
+    AR_GLINE_CHECKED,   /**< checked for a G-line banning the client */
     AR_NUM_FLAGS
 };
 
@@ -201,6 +203,8 @@ struct IAuth {
 
 /** Active instance of IAuth. */
 static struct IAuth *iauth;
+/** IAuth respawn timer. */
+static struct Timer iauth_spawn_timer;
 /** Freelist of AuthRequest structures. */
 static struct AuthRequest *auth_freelist;
 
@@ -211,6 +215,31 @@ static int preregister_user(struct Client *cptr);
 typedef int (*iauth_cmd_handler)(struct IAuth *iauth, struct Client *cli,
 				 int parc, char **params);
 
+/** Copies a username, cleaning it in the process.
+ *
+ * @param[out] dest Destination buffer for user name.
+ * @param[in] src Source buffer for user name.  Must be distinct from
+ *   \a dest.
+ */
+void clean_username(char *dest, const char *src)
+{
+  int rlen = USERLEN;
+  char ch;
+
+  /* First character can be ~, later characters cannot. */
+  if (!IsCntrl(*src))
+  {
+    ch = *src++;
+    *dest++ = IsUserChar(ch) ? ch : '_';
+    rlen--;
+  }
+  while (rlen-- && !IsCntrl(ch = *src++))
+  {
+    *dest++ = (IsUserChar(ch) && (ch != '~')) ? ch : '_';
+  }
+  *dest = '\0';
+}
+
 /** Set username for user associated with \a auth.
  * @param[in] auth Client authorization request to work on.
  * @return Zero if client is kept, CPTR_KILLED if client rejected.
@@ -221,41 +250,26 @@ static int auth_set_username(struct AuthRequest *auth)
   struct User   *user = cli_user(sptr);
   char *d;
   char *s;
-  int   rlen = USERLEN;
-  int   killreason;
-  short character = 0;
+  short upper = 0;
+  short lower = 0;
+  short leadcaps = 0;
+  short character = 0;;
   short pos = 0;
   short other = 0;
   short digits = 0;
+  short digitgroups = 0;
   char  ch;
   char  last;
 
-  if (FlagHas(&auth->flags, AR_IAUTH_USERNAME))
+  if (FlagHas(&auth->flags, AR_IAUTH_FUSERNAME))
   {
-      ircd_strncpy(cli_user(sptr)->username, cli_username(sptr), USERLEN);
+    ircd_strncpy(user->username, cli_username(sptr), USERLEN);
   }
-  else
+  else if (IsIdented(sptr))
   {
-    /* Copy username from source to destination.  Since they may be the
-     * same, and we may prefix with a '~', use a buffer character (ch)
-     * to hold the next character to copy.
-     */
-    s = IsIdented(sptr) ? cli_username(sptr) : user->username;
-    last = *s++;
-    d = user->username;
-    if (HasFlag(sptr, FLAG_DOID) && !IsIdented(sptr))
-    {
-      *d++ = '~';
-      --rlen;
-    }
-    while (last && !IsCntrl(last) && rlen--)
-    {
-      ch = *s++;
-      *d++ = IsUserChar(last) ? last : '_';
-      last = (ch != '~') ? ch : '_';
-    }
-    *d = 0;
+    clean_username(user->username, cli_username(sptr));
   }
+  /* else username was set by identd lookup (or failure thereof) */
 
   /* If username is empty or just ~, reject. */
   if ((user->username[0] == '\0')
@@ -265,14 +279,6 @@ static int auth_set_username(struct AuthRequest *auth)
   /* Have to set up "realusername" before doing the gline check below */
   ircd_strncpy(user->realusername, user->username, USERLEN);
 
-  /* Check for K- or G-line. */
-  killreason = find_kill(sptr, 1);
-  if (killreason) {
-    ServerStats->is_ref++;
-    return exit_client(sptr, sptr, &me,
-                       (killreason == -1 ? "K-lined" : "G-lined"));
-  }
-
   if (!FlagHas(&auth->flags, AR_IAUTH_FUSERNAME))
   {
     /* Check for mixed case usernames, meaning probably hacked.  Jon2 3-94
@@ -326,6 +332,50 @@ badid:
   return exit_client(sptr, sptr, &me, "USER: Bad username");
 }
 
+/** Notifies IAuth of a status change for the client.
+ *
+ * @param[in] auth Authorization request that was updated.
+ * @param[in] flag Which flag was updated.
+ */
+static void iauth_notify(struct AuthRequest *auth, enum AuthRequestFlag flag)
+{
+  struct Client *sptr = auth->client;
+
+  switch (flag)
+  {
+  case AR_AUTH_PENDING:
+    if (IAuthHas(iauth, IAUTH_UNDERNET))
+      sendto_iauth(sptr, "u %s", cli_user(sptr)->username);
+    break;
+
+  case AR_DNS_PENDING:
+    if (cli_sockhost(auth->client)[0] == '\0')
+      sendto_iauth(sptr, "d");
+    else
+      sendto_iauth(sptr, "N %s", cli_sockhost(auth->client));
+    break;
+
+  case AR_NEEDS_USER:
+    if (IAuthHas(iauth, IAUTH_UNDERNET))
+      sendto_iauth(sptr, "U %s :%s", cli_user(sptr)->username, cli_info(sptr));
+    else if (IAuthHas(iauth, IAUTH_ADDLINFO))
+      sendto_iauth(sptr, "U %s", cli_user(sptr)->username);
+    break;
+
+  case AR_NEEDS_NICK:
+    if (IAuthHas(iauth, IAUTH_UNDERNET))
+      sendto_iauth(auth->client, "n %s", cli_name(sptr));
+    break;
+
+  case AR_IAUTH_PENDING:
+    sendto_iauth(sptr, "T");
+    break;
+
+  default:
+    break;
+  }
+}
+
 /** Check whether an authorization request is complete.
  * This means that no flags from 0 to #AR_LAST_SCAN are set on \a auth.
  * If #AR_IAUTH_PENDING is set, optionally go into "hurry" state.  If
@@ -335,48 +385,89 @@ badid:
  * @param[in] auth Authorization request to check.
  * @return Zero if client is kept, CPTR_KILLED if client rejected.
  */
-static int check_auth_finished(struct AuthRequest *auth)
+static int check_auth_finished(struct AuthRequest *auth, int bitclr)
 {
   enum AuthRequestFlag flag;
+  int from_iauth;
+  int hurry_up;
   int res;
 
-  /* Check non-iauth registration blocking flags. */
-  for (flag = 0; flag <= AR_LAST_SCAN; ++flag)
-    if (FlagHas(&auth->flags, flag))
-    {
-      Debug((DEBUG_INFO, "Auth %p [%d] still has flag %d", auth,
-             cli_fd(auth->client), flag));
+  /* Handle \a bitclr. */
+  from_iauth = (bitclr < 0);
+  if (from_iauth)
+    bitclr = -bitclr;
+  if (bitclr != AR_IAUTH_SOFT_DONE)
+    FlagClr(&auth->flags, bitclr);
+
+  if (IsUserPort(auth->client)
+      && !FlagHas(&auth->flags, AR_GLINE_CHECKED))
+  {
+    struct User   *user;
+    struct Client *sptr;
+    int killreason;
+
+    /* Bail out until we have DNS and ident. */
+    if (FlagHas(&auth->flags, AR_AUTH_PENDING)
+        || FlagHas(&auth->flags, AR_DNS_PENDING)
+        || FlagHas(&auth->flags, AR_NEEDS_USER))
       return 0;
+
+    /* Copy username to struct User.username for kill checking. */
+    sptr = auth->client;
+    user = cli_user(sptr);
+    if (IsIdented(sptr))
+    {
+      clean_username(user->username, cli_username(sptr));
+    }
+    else if (cli_wline(sptr)) /* trust USER if we trusted WEBIRC */
+    {
+      ircd_strncpy(cli_username(sptr), user->username, USERLEN);
+    }
+    else if (DoIdentLookups)
+    {
+      /* Prepend ~ to user->username. */
+      char *s = user->username;
+      int ii;
+      for (ii = USERLEN-1; ii > 0; ii--)
+        s[ii] = s[ii-1];
+      s[0] = (cli_wline(sptr) && !feature_bool(FEAT_HIS_WEBIRC))
+        ? '^' : '~';
+      s[USERLEN] = '\0';
+    } /* else cleaned version of client-provided name is in place */
+
+    /* Check for K- or G-line. */
+    FlagSet(&auth->flags, AR_GLINE_CHECKED);
+    killreason = find_kill(sptr, 1);
+    if (killreason)
+    {
+      ++ServerStats->is_ref;
+      return exit_client(sptr, sptr, &me,
+                         (killreason == -1 ? "K-lined" : "G-lined"));
     }
 
-  /* If appropriate, do preliminary assignment to connection class. */
-  if (IsUserPort(auth->client)
-      && !FlagHas(&auth->flags, AR_IAUTH_HURRY)
-      && preregister_user(auth->client))
-    return CPTR_KILLED;
+    /* Tell IAuth about the client. */
+    for (flag = 1; flag <= AR_LAST_SCAN; ++flag)
+    {
+      if (!FlagHas(&auth->flags, flag))
+        iauth_notify(auth, flag);
+    }
+  }
 
-  /* If we have not done so, check client password.  Do this as soon
-   * as possible so that iauth's challenge/response (which uses PASS
-   * for responses) is not confused with the client's password.
-   */
-  if (IsUserPort(auth->client)
-      && !FlagHas(&auth->flags, AR_PASSWORD_CHECKED))
+  /* Check non-iauth registration blocking flags. */
+  for (flag = 1; flag <= AR_LAST_SCAN; ++flag)
   {
-    struct ConfItem *aconf;
-
-    aconf = cli_confs(auth->client)->value.aconf;
-    if (aconf
-        && !EmptyString(aconf->passwd)
-        && strcmp(cli_passwd(auth->client), aconf->passwd))
+    if (FlagHas(&auth->flags, flag))
     {
-      ServerStats->is_ref++;
-      send_reply(auth->client, ERR_PASSWDMISMATCH);
-      return exit_client(auth->client, auth->client, &me, "Bad Password");
+      Debug((DEBUG_INFO, "Auth %p [%d] still has flag %d", auth,
+             cli_fd(auth->client), flag));
+      if (!from_iauth)
+        iauth_notify(auth, (enum AuthRequestFlag)bitclr);
+      return 0;
     }
-    FlagSet(&auth->flags, AR_PASSWORD_CHECKED);
   }
 
   /* Check if iauth is done. */
+  hurry_up = 0;
   if (FlagHas(&auth->flags, AR_IAUTH_PENDING))
   {
     /* Switch auth request to hurry-up state. */
@@ -384,16 +475,21 @@ static int check_auth_finished(struct AuthRequest *auth)
     {
       /* Set "hurry" flag in auth request. */
       FlagSet(&auth->flags, AR_IAUTH_HURRY);
-
-      /* If iauth wants it, send notification. */
-      if (IAuthHas(iauth, IAUTH_UNDERNET))
-        sendto_iauth(auth->client, "H %s", get_client_class(auth->client));
+      hurry_up = 1;
 
       /* If iauth wants it, give client more time. */
       if (IAuthHas(iauth, IAUTH_EXTRAWAIT))
         cli_firsttime(auth->client) = CurrentTime;
     }
 
+    /* Notify IAuth (if appropriate). */
+    if (!from_iauth)
+      iauth_notify(auth, (enum AuthRequestFlag)bitclr);
+
+    /* Do we need to tell IAuth to hurry up? */
+    if (hurry_up && IAuthHas(iauth, IAUTH_UNDERNET))
+      sendto_iauth(auth->client, "H");
+
     Debug((DEBUG_INFO, "Auth %p [%d] still has flag %d", auth,
            cli_fd(auth->client), AR_IAUTH_PENDING));
     return 0;
@@ -401,15 +497,44 @@ static int check_auth_finished(struct AuthRequest *auth)
   else
     FlagSet(&auth->flags, AR_IAUTH_HURRY);
 
+  res = 0;
   if (IsUserPort(auth->client))
   {
-    memset(cli_passwd(auth->client), 0, sizeof(cli_passwd(auth->client)));
+    struct Client *cptr = auth->client;
+
+    ircd_strncpy(cli_user(cptr)->host, cli_sockhost(cptr), HOSTLEN);
+    ircd_strncpy(cli_user(cptr)->realhost, cli_sockhost(cptr), HOSTLEN);
     res = auth_set_username(auth);
+
+    /* If client has an attached conf, IAuth assigned a class; use it.
+     * Otherwise, assign to a Client block and check password.
+     */
+    if ((res == 0) && !cli_confs(cptr))
+    {
+      struct ConfItem *aconf;
+
+      /* If appropriate, do preliminary assignment to Client block. */
+      if ((res == 0) && preregister_user(cptr))
+        res = CPTR_KILLED;
+
+      /* Check password. */
+      if ((res == 0)
+          && ((aconf = cli_confs(cptr)->value.aconf) != NULL)
+          && !EmptyString(aconf->passwd)
+          && strcmp(cli_passwd(cptr), aconf->passwd))
+      {
+        ++ServerStats->is_ref;
+        send_reply(cptr, ERR_PASSWDMISMATCH);
+        res = exit_client(cptr, cptr, &me, "Bad Password");
+      }
+    }
+
     if (res == 0)
-      res = register_user(auth->client, auth->client);
+    {
+      memset(cli_passwd(cptr), 0, sizeof(cli_passwd(cptr)));
+      res = register_user(cptr, cptr);
+    }
   }
-  else
-    res = 0;
   if (res == 0)
     destroy_auth_request(auth);
   return res;
@@ -435,6 +560,26 @@ auth_verify_hostname(const char *host, int maxlen)
   return 1; /* it's a valid hostname */
 }
 
+/** Check whether a client already has a CONF_CLIENT configuration
+ * item.
+ *
+ * @return A pointer to the client's first CONF_CLIENT, or NULL if
+ *   there are none.
+ */
+static struct ConfItem *find_conf_client(struct Client *cptr)
+{
+  struct SLink *list;
+
+  for (list = cli_confs(cptr); list != NULL; list = list->next) {
+    struct ConfItem *aconf;
+    aconf = list->value.aconf;
+    if (aconf->status & CONF_CLIENT)
+      return aconf;
+  }
+
+  return NULL;
+}
+
 /** Assign a client to a connection class.
  * @param[in] cptr Client to assign to a class.
  * @return Zero if client is kept, CPTR_KILLED if rejected.
@@ -444,8 +589,9 @@ static int preregister_user(struct Client *cptr)
   static time_t last_too_many1;
   static time_t last_too_many2;
 
-  ircd_strncpy(cli_user(cptr)->host, cli_sockhost(cptr), HOSTLEN);
-  ircd_strncpy(cli_user(cptr)->realhost, cli_sockhost(cptr), HOSTLEN);
+  if (find_conf_client(cptr)) {
+    return 0;
+  }
 
   switch (conf_check_client(cptr))
   {
@@ -477,7 +623,7 @@ static int preregister_user(struct Client *cptr)
     /* Can this ever happen? */
   case ACR_BAD_SOCKET:
     ++ServerStats->is_ref;
-    IPcheck_connect_fail(cptr);
+    IPcheck_connect_fail(cptr);
     return exit_client(cptr, cptr, &me, "Unknown error -- Try again");
   }
   return 0;
@@ -507,8 +653,7 @@ static void send_auth_query(struct AuthRequest* auth)
     ++ServerStats->is_abad;
     if (IsUserPort(auth->client))
       sendheader(auth->client, REPORT_FAIL_ID);
-    FlagClr(&auth->flags, AR_AUTH_PENDING);
-    check_auth_finished(auth);
+    check_auth_finished(auth, AR_AUTH_PENDING);
   }
 }
 
@@ -639,8 +784,7 @@ static void read_auth_reply(struct AuthRequest* auth)
       sendto_iauth(auth->client, "u %s", username);
   }
 
-  FlagClr(&auth->flags, AR_AUTH_PENDING);
-  check_auth_finished(auth);
+  check_auth_finished(auth, AR_AUTH_PENDING);
 }
 
 /** Handle socket I/O activity.
@@ -740,13 +884,12 @@ int auth_ping_timeout(struct Client *cptr)
 
   /* Check for iauth timeout. */
   if (FlagHas(&auth->flags, AR_IAUTH_PENDING)) {
-    sendto_iauth(cptr, "T");
-    if (IAuthHas(iauth, IAUTH_REQUIRED)) {
+    if (IAuthHas(iauth, IAUTH_REQUIRED)
+        && !FlagHas(&auth->flags, AR_IAUTH_SOFT_DONE)) {
       sendheader(cptr, REPORT_FAIL_IAUTH);
       return exit_client_msg(cptr, cptr, &me, "Authorization Timeout");
     }
-    FlagClr(&auth->flags, AR_IAUTH_PENDING);
-    return check_auth_finished(auth);
+    return check_auth_finished(auth, AR_IAUTH_PENDING);
   }
 
   assert(0 && "Unexpectedly reached end of auth_ping_timeout()");
@@ -767,27 +910,31 @@ static void auth_timeout_callback(struct Event* ev)
   auth = (struct AuthRequest*) t_data(ev_timer(ev));
 
   if (ev_type(ev) == ET_EXPIRE) {
+    int flag = 0;
+
     /* Report the timeout in the log. */
     log_write(LS_RESOLVER, L_INFO, 0, "Registration timeout %s",
               get_client_name(auth->client, HIDE_IP));
 
     /* Notify client if ident lookup failed. */
     if (FlagHas(&auth->flags, AR_AUTH_PENDING)) {
-      FlagClr(&auth->flags, AR_AUTH_PENDING);
+      flag = AR_AUTH_PENDING;
       if (IsUserPort(auth->client))
         sendheader(auth->client, REPORT_FAIL_ID);
     }
 
     /* Likewise if dns lookup failed. */
     if (FlagHas(&auth->flags, AR_DNS_PENDING)) {
-      FlagClr(&auth->flags, AR_DNS_PENDING);
+      if (flag != 0)
+        FlagClr(&auth->flags, flag);
+      flag = AR_DNS_PENDING;
       delete_resolver_queries(auth);
       if (IsUserPort(auth->client))
         sendheader(auth->client, REPORT_FAIL_DNS);
     }
 
     /* Try to register the client. */
-    check_auth_finished(auth);
+    check_auth_finished(auth, flag);
   }
 }
 
@@ -834,7 +981,7 @@ static void auth_dns_callback(void* vptr, const struct irc_in_addr *addr, const
     ircd_strncpy(cli_sockhost(auth->client), h_name, HOSTLEN);
     sendto_iauth(auth->client, "N %s", h_name);
   }
-  check_auth_finished(auth);
+  check_auth_finished(auth, AR_DNS_PENDING);
 }
 
 /** Flag the client to show an attempt to contact the ident server on
@@ -969,28 +1116,33 @@ void start_auth(struct Client* client)
   }
   auth->port = remote.port;
 
-  /* Try to start DNS lookup. */
-  start_dns_query(auth);
-
-  /* Try to start ident lookup. */
-  start_auth_query(auth);
-
   /* Set required client inputs for users. */
-  if (IsUserPort(client)) {
+  if (IsUserPort(client) || IsWebircPort(client)) {
     cli_user(client) = make_user(client);
     cli_user(client)->server = &me;
     FlagSet(&auth->flags, AR_NEEDS_USER);
     FlagSet(&auth->flags, AR_NEEDS_NICK);
 
-    /* Try to start iauth lookup. */
-    start_iauth_query(auth);
+    if (IsUserPort(client)) {
+      /* Try to start iauth lookup. */
+      start_iauth_query(auth);
+    }
   }
 
+  if (!IsWebircPort(client)) {
+    /* Try to start DNS lookup. */
+    start_dns_query(auth);
+
+    /* Try to start ident lookup. */
+    if (DoIdentLookups)
+      start_auth_query(auth);
+  } 
+
   /* Add client to GlobalClientList. */
   add_client_to_list(client);
 
   /* Check which auth events remain pending. */
-  check_auth_finished(auth);
+  check_auth_finished(auth, 0);
 }
 
 /** Mark that a user has PONGed while unregistered.
@@ -1010,8 +1162,7 @@ int auth_set_pong(struct AuthRequest *auth, unsigned int cookie)
     return 0;
   }
   cli_lasttime(auth->client) = CurrentTime;
-  FlagClr(&auth->flags, AR_NEEDS_PONG);
-  return check_auth_finished(auth);
+  return check_auth_finished(auth, AR_NEEDS_PONG);
 }
 
 /** Record a user's claimed username and userinfo.
@@ -1031,16 +1182,15 @@ int auth_set_user(struct AuthRequest *auth, const char *username, const char *ho
   assert(auth != NULL);
   if (FlagHas(&auth->flags, AR_IAUTH_HURRY))
     return 0;
-  FlagClr(&auth->flags, AR_NEEDS_USER);
   cptr = auth->client;
   ircd_strncpy(cli_info(cptr), userinfo, REALLEN);
-  ircd_strncpy(cli_user(cptr)->username, username, USERLEN);
+  clean_username(cli_user(cptr)->username, username);
   ircd_strncpy(cli_user(cptr)->host, cli_sockhost(cptr), HOSTLEN);
   if (IAuthHas(iauth, IAUTH_UNDERNET))
     sendto_iauth(cptr, "U %s %s %s :%s", username, hostname, servername, userinfo);
   else if (IAuthHas(iauth, IAUTH_ADDLINFO))
     sendto_iauth(cptr, "U %s", username);
-  return check_auth_finished(auth);
+  return check_auth_finished(auth, AR_NEEDS_USER);
 }
 
 /** Handle authorization-related aspects of initial nickname selection.
@@ -1052,7 +1202,6 @@ int auth_set_user(struct AuthRequest *auth, const char *username, const char *ho
 int auth_set_nick(struct AuthRequest *auth, const char *nickname)
 {
   assert(auth != NULL);
-  FlagClr(&auth->flags, AR_NEEDS_NICK);
   /*
    * If the client hasn't gotten a cookie-ping yet,
    * choose a cookie and send it. -record!jegelhof@cloud9.net
@@ -1066,7 +1215,7 @@ int auth_set_nick(struct AuthRequest *auth, const char *nickname)
   }
   if (IAuthHas(iauth, IAUTH_UNDERNET))
     sendto_iauth(auth->client, "n %s", nickname);
-  return check_auth_finished(auth);
+  return check_auth_finished(auth, AR_NEEDS_NICK);
 }
 
 /** Record a user's password.
@@ -1110,8 +1259,50 @@ int auth_cap_start(struct AuthRequest *auth)
 int auth_cap_done(struct AuthRequest *auth)
 {
   assert(auth != NULL);
-  FlagClr(&auth->flags, AR_CAP_PENDING);
-  return check_auth_finished(auth);
+  return check_auth_finished(auth, AR_CAP_PENDING);
+}
+
+/** Set a client's username, hostname and IP with minimal checking.
+ * (The spoofed values should be from a trusted source.)
+ *
+ * @param[in] auth Authorization request for client.
+ * @param[in] username Requested username (possibly null).
+ * @param[in] hostname Requested hostname.
+ * @param[in] ip Requested IP address.
+ * @return Zero if client should be kept, negative if killed if rejected.
+ */
+int auth_spoof_user(struct AuthRequest *auth, const char *username, const char *hostname, const char *ip)
+{
+  struct Client *sptr = auth->client;
+  time_t next_target = 0;
+
+/**
+  Removed check because ipv6 issue
+  if (!auth_verify_hostname(hostname, HOSTLEN))
+    return 1;
+  if (!ipmask_parse(ip, &cli_ip(sptr), NULL))
+    return 2;
+*/
+  if (!IPcheck_local_connect(&cli_ip(sptr), &next_target)) {
+    ++ServerStats->is_ref;
+    return exit_client(sptr, sptr, &me, "Your host is trying to (re)connect too fast -- throttled");
+  }
+  SetIPChecked(sptr);
+
+  if (next_target)
+    cli_nexttarget(sptr) = next_target;
+  ircd_strncpy(cli_sock_ip(sptr), ip, SOCKIPLEN);
+  ircd_strncpy(cli_sockhost(sptr), hostname, HOSTLEN);
+  if (username) {
+    ircd_strncpy(cli_username(sptr), username, USERLEN);
+    SetGotId(sptr);
+  }
+
+  start_iauth_query(auth);
+  if (username && IAuthHas(iauth, IAUTH_UNDERNET))
+    sendto_iauth(sptr, "u %s", cli_username(sptr));
+
+  return check_auth_finished(auth, 0);
 }
 
 /** Attempt to spawn the process for an IAuth instance.
@@ -1745,14 +1936,15 @@ static int iauth_cmd_ip_address(struct IAuth *iauth, struct Client *cli,
     memcpy(&auth->original, &cli_ip(cli), sizeof(auth->original));
 
   /* Undo original IP connection in IPcheck. */
-  IPcheck_connect_fail(cli);
+  IPcheck_connect_fail(cli);
   ClearIPChecked(cli);
 
   /* Update the IP and charge them as a remote connect. */
   memcpy(&cli_ip(cli), &addr, sizeof(cli_ip(cli)));
   IPcheck_remote_connect(cli, 0);
 
-  return 0;
+  /* Treat as a DNS update to trigger G-line/Kill checks. */
+  return AR_DNS_PENDING;
 }
 
 /** Find a ConfItem structure for a named connection class.
@@ -1792,6 +1984,22 @@ static struct ConfItem *auth_find_class_conf(const char *class_name)
   return aconf;
 }
 
+/** Tentatively accept a client in IAuth.
+ * @param[in] iauth Active IAuth session.
+ * @param[in] cli Client referenced by command.
+ * @param[in] parc Number of parameters.
+ * @param[in] params Optional class name for client.
+ * @return \a AR_IAUTH_SOFT_DONE.
+ */
+static int iauth_cmd_soft_done(struct IAuth *iauth, struct Client *cli,
+			       int parc, char **params)
+{
+  /* Clear iauth pending flag. */
+  assert(cli_auth(cli) != NULL);
+  FlagSet(&cli_auth(cli)->flags, AR_IAUTH_SOFT_DONE);
+  return AR_IAUTH_SOFT_DONE;
+}
+
 /** Accept a client in IAuth.
  * @param[in] iauth Active IAuth session.
  * @param[in] cli Client referenced by command.
@@ -1947,6 +2155,7 @@ static void iauth_parse(struct IAuth *iauth, char *message)
   case 'I': handler = iauth_cmd_ip_address; has_cli = 1; break;
   case 'M': handler = iauth_cmd_usermode; has_cli = 1; break;
   case 'C': handler = iauth_cmd_challenge; has_cli = 1; break;
+  case 'd': handler = iauth_cmd_soft_done; has_cli = 1; break;
   case 'D': handler = iauth_cmd_done_client; has_cli = 1; break;
   case 'R': handler = iauth_cmd_done_account; has_cli = 1; break;
   case 'k': /* The 'k' command indicates the user should be booted
@@ -2014,10 +2223,14 @@ static void iauth_parse(struct IAuth *iauth, char *message)
 	/* Report mismatch to iauth. */
 	sendto_iauth(cli, "E Mismatch :[%s] != [%s]", params[1],
 		     ircd_ntoa(&cli_ip(cli)));
-      else if (handler(iauth, cli, parc - 3, params + 3))
-	/* Handler indicated a possible state change. */
-	check_auth_finished(auth);
-    }
+      else
+      {
+        /* Does handler indicate a possible state change? */
+        int bitclr = handler(iauth, cli, parc - 3, params + 3);
+        if (bitclr > 0)
+          check_auth_finished(auth, -bitclr);
+      }
+	}
   }
 }
 
@@ -2063,6 +2276,18 @@ static void iauth_read(struct IAuth *iauth)
   memcpy(iauth->i_buffer, sol, iauth->i_count);
 }
 
+static void iauth_spawn_callback(struct Event *ev)
+{
+  struct IAuth *iauth;
+
+  assert(0 != ev_timer(ev));
+  assert(0 != t_data(ev_timer(ev)));
+
+  iauth = (struct IAuth*) t_data(ev_timer(ev));
+
+  iauth_do_spawn(iauth, 1);
+}
+
 /** Handle socket activity for an %IAuth connection.
  * @param[in] ev &Socket event; the IAuth connection is the user data
  *   pointer for the socket.
@@ -2078,8 +2303,13 @@ static void iauth_sock_callback(struct Event *ev)
   switch (ev_type(ev)) {
   case ET_DESTROY:
     /* Hm, what happened here? */
-    if (!IAuthHas(iauth, IAUTH_CLOSING))
-      iauth_do_spawn(iauth, 1);
+    if (!IAuthHas(iauth, IAUTH_CLOSING)) {
+      /* We must not respawn the IAuth instance right here because this callback
+       * function may have been called by iauth_disconnect() - which would garble our
+       * IAuth sockets once we return from this function. */
+      timer_add(timer_init(&iauth_spawn_timer), iauth_spawn_callback, (void *)iauth,
+        TT_RELATIVE, 1);
+    }
     break;
   case ET_READ:
     iauth_read(iauth);
diff --git a/ircd/s_bsd.c b/ircd/s_bsd.c
index 5d22a02..2146eb3 100644
--- a/ircd/s_bsd.c
+++ b/ircd/s_bsd.c
@@ -497,6 +497,10 @@ void add_connection(struct Listener* listener, int fd) {
   {
     new_client = make_client(0, STAT_UNKNOWN_SERVER);
   }
+  else if (listener_webirc(listener))
+  {
+      new_client = make_client(0, STAT_WEBIRC);
+  }
   else
   {
     /*
diff --git a/ircd/s_conf.c b/ircd/s_conf.c
index 95577f8..04b7703 100644
--- a/ircd/s_conf.c
+++ b/ircd/s_conf.c
@@ -76,6 +76,11 @@ struct s_map     *GlobalServiceMapList;
 struct qline     *GlobalQuarantineList;
 /** Global list of spoofhosts. */
 struct sline    *GlobalSList = 0;
+/** Global list of webirc authorizations. */
+struct wline*      GlobalWebircList;
+
+/** Flag for whether to perform ident lookups. */
+int DoIdentLookups;
 
 /** Current line number in scanner input. */
 int lineno;
@@ -801,6 +806,23 @@ find_quarantine(const char *chname)
   return NULL;
 }
 
+/** Find a WebIRC authorization for the given client address.
+ * @param addr IP address to search for.
+ * @param passwd Client-provided password for block.
+ * @return WebIRC authorization block, or NULL if none exists.
+ */
+const struct wline *
+find_webirc(const struct irc_in_addr *addr, const char *passwd)
+{
+  struct wline *wline;
+
+  for (wline = GlobalWebircList; wline; wline = wline->next)
+    if (ipmask_check(addr, &wline->ip, wline->bits)
+        && (0 == strcmp(wline->passwd, passwd)))
+      return wline;
+  return NULL;
+}
+
 /** Free all qline structs from #GlobalQuarantineList. */
 void clear_quarantines(void)
 {
@@ -814,6 +836,31 @@ void clear_quarantines(void)
   }
 }
 
+/** Mark everything in #GlobalWebircList stale. */
+static void webirc_mark_stale(void)
+{
+  struct wline *wline;
+  for (wline = GlobalWebircList; wline; wline = wline->next)
+    wline->stale = 1;
+}
+
+/** Remove any still-stale entries in #GlobalWebircList. */
+static void webirc_remove_stale(void)
+{
+  struct wline *wline, **pp_w;
+
+  for (pp_w = &GlobalWebircList; (wline = *pp_w) != NULL; ) {
+    if (wline->stale) {
+      *pp_w = wline->next;
+      MyFree(wline->passwd);
+      MyFree(wline->description);
+      MyFree(wline);
+    } else {
+      pp_w = &wline->next;
+    }
+  }
+}
+
 /** When non-zero, indicates that a configuration error has been seen in this pass. */
 static int conf_error;
 /** When non-zero, indicates that the configuration file was loaded at least once. */
@@ -951,7 +998,9 @@ int rehash(struct Client *cptr, int sig)
   class_mark_delete();
   mark_listeners_closing();
   auth_mark_closing();
+  webirc_mark_stale();
   close_mappings();
+  DoIdentLookups = 0;
 
   read_configuration_file();
 
@@ -980,6 +1029,7 @@ int rehash(struct Client *cptr, int sig)
 
   for (i = 0; i <= HighestFd; i++) {
     if ((acptr = LocalClientArray[i])) {
+      const struct wline *wline;
       assert(!IsMe(acptr));
       if (IsServer(acptr))
         det_confs_butmask(acptr, ~(CONF_UWORLD | CONF_ILLEGAL));
@@ -996,11 +1046,16 @@ int rehash(struct Client *cptr, int sig)
         if (exit_client(cptr, acptr, &me, found_g == -2 ? "G-lined" :
             "K-lined") == CPTR_KILLED)
           ret = CPTR_KILLED;
+      } else if ((wline = cli_wline(acptr)) && wline->stale) {
+        if (exit_client(cptr, acptr, &me, "WebIRC authorization removed")
+            == CPTR_KILLED)
+          ret = CPTR_KILLED;
       }
     }
   }
 
   attach_conf_uworld(&me);
+  webirc_remove_stale();
 
   return ret;
 }
diff --git a/ircd/s_err.c b/ircd/s_err.c
index 9ea3f41..99c2741 100644
--- a/ircd/s_err.c
+++ b/ircd/s_err.c
@@ -472,7 +472,7 @@ static Numeric replyTable[] = {
 /* 219 */
   { RPL_ENDOFSTATS, "%s :End of /STATS report", "219" },
 /* 220 */
-  { 0 },
+  { RPL_STATSWLINE, "W %s %d :%s", "220" },
 /* 221 */
   { RPL_UMODEIS, "%s", "221" },
 /* 222 */
@@ -672,7 +672,7 @@ static Numeric replyTable[] = {
 /* 319 */
   { RPL_WHOISCHANNELS, "%s :%s", "319" },
 /* 320 */
-  { 0 },
+  { RPL_WHOISWEBIRC, "%s :is connected via %s", "320" },
 /* 321 */
   { RPL_LISTSTART, "Channel :Users  Name", "321" },
 /* 322 */
diff --git a/ircd/s_misc.c b/ircd/s_misc.c
index cf32bea..cb4095b 100644
--- a/ircd/s_misc.c
+++ b/ircd/s_misc.c
@@ -381,6 +381,9 @@ int exit_client(struct Client *cptr,
 
     on_for = CurrentTime - cli_firsttime(victim);
 
+    /* This intentionally excludes WebIRC ports to make port scanning
+     * for it a little harder.
+     */
     if (IsUser(victim) || IsUserPort(victim))
       auth_send_exit(victim);
 
diff --git a/ircd/s_stats.c b/ircd/s_stats.c
index faa40b1..305ee72 100644
--- a/ircd/s_stats.c
+++ b/ircd/s_stats.c
@@ -532,6 +532,29 @@ stats_servers_verbose(struct Client* sptr, const struct StatDesc* sd,
   }
 }
 
+/** Lists WebIRC authorizations.
+ * @param[in] to Client requesting statistics.
+ * @param[in] sd Stats descriptor for request (ignored).
+ * @param[in] param Extra parameter from user (ignored).
+ */
+static void
+stats_webirc(struct Client *to, const struct StatDesc *sd, char *param)
+{
+  struct wline *wline;
+  char ip_text[SOCKIPLEN + 1];
+
+  for (wline = GlobalWebircList; wline; wline = wline->next) {
+    const char *desc = wline->description;
+    if (!desc)
+      desc = "(no description provided)";
+    if (wline->hidden)
+      strcpy(ip_text, "*");
+    else
+      ircd_ntoa_r(ip_text, &wline->ip);
+    send_reply(to, RPL_STATSWLINE, ip_text, wline->bits, desc);
+  }
+}
+
 /** Display objects allocated (and total memory used by them) for
  * several types of structures.
  * @param[in] to Client requesting statistics.
@@ -653,6 +676,9 @@ struct StatDesc statsinfo[] = {
   { 'w', "userload", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_w,
     calc_load, 0,
     "Userload statistics." },
+  { 'W', "webirc", (STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS), FEAT_HIS_STATS_W,
+    stats_webirc, 0,
+    "WebIRC authorizations." },
   { 'x', "memusage", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_x,
     stats_meminfo, 0,
     "List usage information." },
diff --git a/ircd/s_user.c b/ircd/s_user.c
index 7f28f0c..bad1a40 100644
--- a/ircd/s_user.c
+++ b/ircd/s_user.c
@@ -460,8 +460,9 @@ int register_user(struct Client *cptr, struct Client *sptr)
    * their hostmask here.  Calling hide_hostmask() from IAuth's
    * account assignment causes a numeric reply during registration.
    */
-  if (HasHiddenHost(sptr))
+  if (HasHiddenHost(sptr)) {
     hide_hostmask(sptr, FLAG_HIDDENHOST);
+  }
   if (IsInvisible(sptr))
     ++UserStats.inv_clients;
   if (IsOper(sptr))
@@ -953,7 +954,6 @@ int
 hide_hostmask(struct Client *cptr, unsigned int flag)
 {
   struct Membership *chan;
-
   switch (flag) {
   case FLAG_HIDDENHOST:
     /* Local users cannot set +x unless FEAT_HOST_HIDING is true. */
@@ -1233,7 +1233,6 @@ int set_user_mode(struct Client *cptr, struct Client *sptr, int parc,
   size_t opernamelen;
   char *opername = 0;
   char* account = NULL;
-
   hostmask = password = NULL;
   what = MODE_ADD;
 
@@ -1519,8 +1518,9 @@ int set_user_mode(struct Client *cptr, struct Client *sptr, int parc,
       }
       ircd_strncpy(cli_user(sptr)->account, account, len);
   }
-  if (!FlagHas(&setflags, FLAG_HIDDENHOST) && do_host_hiding && allow_modes != ALLOWMODES_DEFAULT)
+  if (!FlagHas(&setflags, FLAG_HIDDENHOST) && do_host_hiding && allow_modes != ALLOWMODES_DEFAULT) {
     hide_hostmask(sptr, FLAG_HIDDENHOST);
+  }
   if (do_set_host) {
     /* We clear the flag in the old mask, so that the +h will be sent */
     /* Only do this if we're SETTING +h and it succeeded */
-- 
2.34.1

